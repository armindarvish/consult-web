
* consult-web
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./consult-web.el
:END:
** Header
#+begin_src emacs-lisp
;;; consult-web.el --- Consulting Web Search Engines -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.2
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

#+end_src

** Requirements
#+begin_src emacs-lisp
;;; Requirements
(eval-when-compile
  (when (featurep 'json)
    (require 'json))
  (when (featurep 'request)
    (require 'request))
  (when (featurep 'plz)
    (require 'plz))
  )
(require 'consult)
(require 'url)
#+end_src


** Define Group, Customs, Vars, Etc.
*** group
#+begin_src emacs-lisp
;;; Group
(defgroup consult-web nil
  "Consulting search engines and AI assistants"
  :group 'convenience
  :group 'minibuffer
  :group 'consult
  :group 'web
  :group 'search
  :prefix "consult-web-")
#+end_src

*** customization variables
#+begin_src emacs-lisp
;;; Customization Variables
(defcustom consult-web-sources-modules-to-load  (list)
  "List of source modules/features to load.

This variable is a list of symbols;
each symbol being a source featue (e.g. consult-web-brave)"
  :type '(repeat :tag "list of source modules/features to load" symbol))

(defcustom consult-web-default-browse-function #'browse-url
  "consult-web default function when selecting a link"
  :type '(choice (function :tag "(Default) Browse URL" #'browse-url)
                 (function :tag "Custom Function")))

(defcustom consult-web-default-format-candidate #'consult-web--highlight-format-candidate
  "consult-web default function when selecting a link"
  :type '(choice (function :tag "(Default) Adds Metadata and Highlights Query" #'consult-web--highlight-format-candidate)
                 (function :tag "Simple and Fast Foramting (No Metadata)" #'consult-web--simple-format-candidate)
                 (function :tag "Custom Function")))


(defcustom consult-web-alternate-browse-function #'eww-browse-url
  "consult-web default function when selecting a link"
  :type '(choice (function :tag "(Default) EWW" #'eww-browse-url)
                 (function :tag "Custom Function")))

(defcustom consult-web-default-preview-function #'eww-browse-url
  "consult-web default function when previewing a link"
  :type '(choice (function :tag "(Default) EWW" #'eww-browse-url)
                 (function :tag "Custom Function")))


(defcustom consult-web-show-preview nil
  "Should`consult-web' show previews?
This turns previews on/off globally for all consult-web sources."
  :type 'boolean)

(defcustom consult-web-preview-key consult-preview-key
  "Preview key for consult-web.
This is similar to `consult-preview-key' but explicitly For consult-web."
  :type '(choice (const :tag "Any Key" Any)
                 (List :tag "Debounced"
                       (const :Debounce)
                       (Float :tag "Seconds" 0.1)
                       (const Any))
                 (const :tag "No Preview" nil)
                 (Key :tag "Key")
                 (repeat :tag "List Of Keys" Key)))

(defcustom consult-web-default-count 5
  "Number Of search results to retrieve."
  :type 'integer)

(defcustom consult-web-default-page 0
  "Offset of search results to retrieve.
If this is set to N, the first N “pages”
(or other first N entities, items for example,
depending On the source search engine capabilities)
of the search results are omitted and the rest are shown."
  :type 'integer)

(defcustom consult-web-default-timeout 30
  "Default timeout in seconds for
`consult-web--url-retrieve-synchronously."
  :type 'integer)

(defcustom consult-web-log nil
  "Default timeout in seconds for
`consult-web--url-retrieve-synchronously."
  :type 'boolean)

(defcustom consult-web-log-buffer-name " *consult-web-log*"
"String for consult-web-log buffer name"
:type 'string)

(defcustom consult-web-log-level nil
  "How to make logs for consult-web requests?
This can be set to nil, info or debug
nil: Does not log anything
info: Logs urls and response's http header
debug: Logs urls and the entire http response.

When non-nil, information is logged to `consult-web-log-buffer-name'."
  :type '(choice
          (const :tag "No Logging" nil)
          (const :tag "Just HTTP Header" info)
          (const :tag "Full Response" debug)))

(defcustom consult-web-group-by :source
  "What field to use to group the results in the minibuffer?

By default it is set to :domain. but can be any of:

  :url      group by URL
  :domain   group by the domain of the URL
  :source   group by source
 "
  :type '(radio (const :tag "url path" :url)
                (const :tag "domain of url path":domain)
                (const :tag "name of the search engine or source" :source)
                (const :tag "custom other field (constant)" :any)
                (const :tag "do not group" nil)))


(defcustom consult-web-multi-sources  (list)
  "List of sources used by `consult-web-multi'.

This variable is a list of strings, each string being name of a source.
The source name has to be a key from `consult-web-sources-alist'.
Sources can be made with the convinient macro `consult-web-define-source'."
  :type '(choice (repeat :tag "list of source names" string)))

(defcustom consult-web-omni-sources  (list)
"List of sources used by `consult-web-omni'.

This variable is a list of strings or symbols;
 - strings can be name of a source, a key from `consult-web-sources-alist',
which can be made with the convinient macro `consult-web-define-source'
or by using `consult-web--make-source-from-consult-source'.
 - symbols can be other consult sources
(see `consult-buffer-sources' for example.)"
:type '(repeat :tag "list of source names" (choice (string symbol))))

(defcustom consult-web-dynamic-omni-sources  (list)
"List of sources used by `consult-web-dynamic-omni'.

This variable is a list of strings, each string being name of a source.
The source name has to be a key from `consult-web-sources-alist'.
Sources can be made with the convinient macro `consult-web-define-source'
or by using `consult-web--make-source-from-consult-source'."
  :type '(choice (repeat :tag "list of source names" string)))

(defcustom consult-web-scholar-sources  (list)
  "List of sources used by `consult-web-scholar'.

This variable is a list of strings, each string being name of a source.
The source name has to be a key from `consult-web-sources-alist'.
Sources can be made with the convinient macro `consult-web-define-source'
or by using `consult-web--make-source-from-consult-source'."
  :type '(choice (repeat :tag "list of source names" string)))

(defcustom consult-web-dynamic-sources  (list)
  "List of sources used by `consult-web-dynamic'.

This variable is a list of strings, each string being name of a source.
The source name has to be a key from `consult-web-sources-alist'.
Sources can be made with the convinient macro `consult-web-define-source'
or by using `consult-web--make-source-from-consult-source'."
  :type '(choice (repeat :tag "list of source names" string)))

(defcustom consult-web-highlight-matches t
  "Should `consult-web' highlight search queries in the minibuffer?"
  :type 'boolean)


(defcustom consult-web-default-interactive-command #'consult-web-multi
  "Which command should `consult-web' call?"
  :type '(choice (function :tag "(Default) Search with dynamic completion (i.e. `consult-web-dynamic')" #'consult-web-dynamic)
                 (function :tag "Search without dynamic completion (i.e. `consult-web-multi')"  #'consult-web-multi)
                 (function :tag "Search academic research literature (i.e. `consult-web-scholar')"  #'consult-web-scholar)
                 (function :tag "Custom function")))

(defcustom consult-web-retrieve-backend #'consult-web-url-retrieve-sync
  "Which command should `consult-web' use for url requests?"
  :type '(choice (function :tag "(Default) url-retrieve backend" #'consult-web-url-retrieve-sync)
                 (function :tag "Emacs Request Backend"  #'consult-web--request-sync)))

(defcustom consult-web-http-retrieve-backend 'url
  "Which command should `consult-web' use for url requests?"
  :type   '(choice
          (const :tag "(Default) Built-in Emacs's url-retrive" 'url)
          (const :tag "`request' backend" 'request)
          (const :tag "`plz' backend" 'plz)))

(defcustom consult-web-default-autosuggest-command nil
  "Which command should `consult-web' use for auto suggestion on search input?"
  :type '(choice (function :tag "(default) use brave autosuggestion (i.e. `consult-web-brave-autosuggest')" #'consult-web-brave-autosuggest)
                 (function :tag "use google autosuggestion (i.e. `consult-web-dynamic-google-autosuggest')" #'consult-web-dynamic-google-autosuggest)
                 (function :tag "custom function")))

(defcustom consult-web-dynamic-input-debounce consult-async-input-debounce
  "Input debounce for dynamic commands.

The dynamic collection process is started only when
there has not been new input for consult-web-dynamic-input-debounce seconds. This is similarto `consult-async-input-debounce' but
specifically for consult-web dynamic commands.

By default inherits from `consult-async-input-debounce'."
  :type '(float :tag "delay in seconds"))


(defcustom consult-web-dynamic-input-throttle consult-async-input-throttle
  "Input throttle for dynamic commands.

The dynamic collection process is started only every
`consult-web-dynamic-input-throttle' seconds. this is similar
to `consult-async-input-throttle' but specifically for
consult-web dynamic commands.

By default inherits from `consult-async-input-throttle'."
  :type '(float :tag "delay in seconds"))

(defcustom consult-web-dynamic-refresh-delay consult-async-refresh-delay
  "refreshing delay of the completion ui for dynamic commands.

The completion UI is only updated every
`consult-web-dynamic-refresh-delay' seconds.
This is similar to `consult-async-refresh-delay' but specifically
for consult-web dynamic commands.

By default inherits from `consult-async-refresh-delay'. "
  :type '(float :tag "delay in seconds"))


#+end_src

*** other variables
#+begin_src emacs-lisp
;;; Other Variables

(defvar consult-web-sources--all-modules-list (list)
"List of all source modules.")

(defvar consult-web-category 'consult-web
  "Category symbol for the consult-web seach")

(defvar consult-web-scholar-category 'consult-web-scholar
  "Category symbol for scholar search")

(defvar consult-web-video-category 'consult-web-video
  "Category symbol for video search")

(defvar consult-web--selection-history (list)
  "History variable that keeps selected items.")

(defvar consult-web--search-history (list)
  "History variable that keeps search terms.")

(defvar consult-web-sources-alist (list)
  "Alist of search engine or ai assistant sources.

This is an alist mapping source names to source property lists.
This alist is used to define how to process data form
a source (e.g. format data) or find what commands to run on
selecting candidates from a source, etc.

You can use the convinient macro `consult-web-define-source'
or the command `consult-web--make-source-from-consult-source'
to add to this alist.")

(defvar consult-web--hidden-buffers-list (list)
  "List of currently open hidden buffers")

(defvar consult-web--override-group-by nil
"Override grouping in `consult-group' based on user input.

This is used in dynamic collection to change grouping.")

(defvar consult-web--current-sources (list)
"List of sources of the candidates in the current minibuffer.

This is used for defining narrow functions
(e.g. `consult-web--dynamic-narrow-function'."
)

#+end_src

*** define faces
#+begin_src emacs-lisp
;;; Faces

(defface consult-web-default-face
  `((t :inherit 'default))
"Default face used for listing items in minibuffer.")

(defface consult-web-prompt-face
  `((t :inherit 'font-lock-variable-use-face))
"The face used for prompts in minibuffer.")

(defface consult-web-engine-source-face
  `((t :inherit 'font-lock-variable-use-face))
"The face for search engine source types in minibuffer.")

(defface consult-web-ai-source-face
  `((t :inherit 'font-lock-operator-face))
"The face for AI assistant source types in minibuffer.")

(defface consult-web-files-source-face
  `((t :inherit 'font-lock-number-face))
"The face for file source types in minibuffer.")

(defface consult-web-notes-source-face
  `((t :inherit 'font-lock-warning-face))
"The face for notes source types in minibuffer.")

(defface consult-web-scholar-source-face
  `((t :inherit 'font-lock-function-call-face))
"The face for academic literature source types in minibuffer.")

(defface consult-web-source-face
  `((t :inherit 'font-lock-comment-face))
"The face for source annotation in minibuffer.")

(defface consult-web-date-face
  `((t :inherit 'font-lock-variable-face))
"The face for date annotation in minibuffer.")

(defface consult-web-domain-face
  `((t :inherit 'font-lock-string-face))
"The face for domain annotation in minibuffer.")

(defface consult-web-path-face
  `((t :inherit 'font-lock-warning-face))
"The face for path annotation in minibuffer.")

(defface consult-web-snippet-face
  `((t :inherit 'font-lock-doc-face))
"The face for source annotation in minibuffer.")

(defface consult-web-highlight-match-face
  `((t :inherit 'consult-highlight-match))
  "Highlight match face for `consult-web'.")

(defface consult-web-preview-match-face
  `((t :inherit 'consult-preview-match))
  "Preview match face in `consult-web' preview buffers.")
#+end_src
** Define Backend Functions
*** general utility
**** properties to plist
#+begin_src emacs-lisp

(defun consult-web-properties-to-plist (string &optional ignore-keys)
"Returns a plist of the text properties of STRING.

Ommits keys in IGNORE-KEYs."
(let ((properties (text-properties-at 0 string))
      (pl nil))
  (cl-loop for k in properties
           when (keywordp k)
           collect (unless (member k ignore-keys) (push (list k (plist-get properties k)) pl)))
  (apply #'append pl)))
#+end_src
**** propertize with plist
#+begin_src emacs-lisp
(defun consult-web-propertize-by-plist (item props)
"Propertizes ITEM by PROPS plist"
  (apply #'propertize item props))
#+end_src

**** formatting strings
***** fix string length
****** set string width
#+begin_src emacs-lisp
;;; Bakcend Functions

(defun consult-web--set-string-width (string width &optional truncate-pos add-pos)
  "Sets the STRING width to a fixed value, WIDTH.

If the STRING is longer than WIDTH, it truncates the STRING
 and adds ellipsis, \"...\". if the STRING is shorter,
it adds whitespace to the STRING.
If TRUNCATE-POS is non-nil, it truncates from position pos in the STRING
If ADD-POS is non-nil, it adds whitespace to the end of STRING.
"
  (let* ((string (format "%s" string))
         (w (length string)))
    (when (< w width)
      (if (and add-pos (< add-pos w))
          (setq string (format "%s%s%s" (substring string 0 add-pos) (consult-web-propertize-by-plist (make-string (- width w) ?\s) (text-properties-at add-pos string)) (substring string add-pos)))
        (setq string (format "%s%s" (substring string) (make-string (- width w) ?\s)))))
    (when (> w width)
      (if (and truncate-pos (< truncate-pos (- width 3)) (>= truncate-pos 0))
          (setq string (format "%s%s%s" (substring string 0 truncate-pos) (consult-web-propertize-by-plist "..." (text-properties-at truncate-pos string)) (substring string (- 0 (- width truncate-pos 3)))))
        (setq string (format "%s%s" (substring string 0 (- width 3)) (consult-web-propertize-by-plist "..." (text-properties-at (max (- width 3) 0) string))))))
    string))
#+end_src
****** justify left
#+begin_src emacs-lisp

(defun consult-web--justify-left (string prefix maxwidth)
  "Sets the width of STRING+PREFIX justified from left.
It uses `consult-web--set-string-width' and sets the width
 of the concatenate of STRING+PREFIX
(e.g. `(concat PREFIX STRING)`) within MAXWIDTH.
This is used for aligning marginalia info in minibuffer."
  (let ((s (length string))
        (w (length prefix)))
    (if (> maxwidth w)
    (consult-web--set-string-width string (- maxwidth w) 0)
    string
          )
    ))

#+end_src
***** shorten url
#+begin_src emacs-lisp
(defun consult-web--set-url-width (domain path width)
  (when (stringp domain)
    (let ((path-width (and (stringp path) (length path)))
          (path-target-width (- width (length domain))))
        (cond
         ((<= path-target-width 0)
          (consult-web--set-string-width domain width))
         ((integerp path-width)
          (concat domain (consult-web--set-string-width path path-target-width (floor (/ path-target-width 2)))))
         (t
          (consult-web--set-string-width (concat domain path) width))))))

#+end_src
***** highlight match with text-properties
#+begin_src emacs-lisp

(defun consult-web--highlight-match (regexp str ignore-case)
  "Highlights REGEXP in STR.

If a regular expression contains capturing groups,
 only these are highlighted.
If no capturing groups are used, highlight the whole match.
Case is ignored, if ignore-case is non-nil.
(This is adapted from `consult--highlight-regexps'.)"
  (let ((i 0))
    (while (and (let ((case-fold-search ignore-case))
                  (string-match regexp str i))
                (> (match-end 0) i))
      (let ((m (match-data)))
        (setq i (cadr m)
              m (or (cddr m) m))
        (while m
          (when (car m)
            (add-face-text-property (car m) (cadr m)
                                     'consult-web-highlight-match-face nil str)
            )
          (setq m (cddr m))))))
  str)
#+end_src
***** highlight match with overlay
#+begin_src emacs-lisp

(defun consult-web--overlay-match (match-str buffer ignore-case)
  "Highlights MATCH-STR in BUFFER using an overlay.
If IGNORE-CASE is non-nil, it uses case-insensitive match.

This is provided for convinience,
if needed in formating candidates or preview buffers."
(with-current-buffer (or (get-buffer buffer) (current-buffer))
  (remove-overlays (point-min) (point-max) 'consult-web-overlay t)
  (goto-char (point-min))
  (let ((case-fold-search ignore-case)
        (consult-web-overlays (list)))
    (while (search-forward match-str nil t)
      (when-let* ((m (match-data))
                  (beg (car m))
                  (end (cadr m))
                  (overlay (make-overlay beg end))
                  )
        (overlay-put overlay 'consult-web-overlay t)
        (overlay-put overlay 'face 'consult-web-highlight-match-face)
        )))))

(defun consult-web-overlays-toggle (&optional buffer)
  "Toggles overlay highlights in consult-web view/preview buffers."
(interactive)
(let ((buffer (or buffer (current-buffer))))
(with-current-buffer buffer
  (dolist (o (overlays-in (point-min) (point-max)))
    (when (overlay-get o 'consult-web-overlay)
      (if (and (overlay-get o 'face) (eq (overlay-get o 'face) 'consult-web-highlight-match-face))
          (overlay-put o 'face nil)
         (overlay-put o 'face 'consult-web-highlight-match-face))
      )
))))
#+end_src


**** make url with params
#+begin_src emacs-lisp

(defun consult-web--make-url-string (url params &optional ignore-keys)
"Adds key value pairs in PARAMS to URL as “&key=val”.

PARMAS should be an alist with keys and values to add to the URL.
Does not add keys for the key in IGNORE-KEYS list."

  (let* ((url (if (equal (substring-no-properties url -1 nil) "?")
                 url
               (concat url "?")))
         (list (append (list url) (cl-loop for (key . value) in params
                                           collect
                                           (unless (member key ignore-keys)
                                             (format "&%s=%s" key value))))))
  (mapconcat #'identity list)))
#+end_src
**** hashtable-to-plist
#+begin_src emacs-lisp

(defun consult-web-hashtable-to-plist (hashtable &optional ignore-keys)
"Converts a HASHTABLE to a plist.

Ommits keys in IGNORE-KEYS."

(let ((pl nil))
    (maphash
     (lambda (k v)
       (unless (member k ignore-keys)
         (push (list k v) pl)))
     hashtable)
    (apply #'append pl)))
#+end_src

**** expand function in variable
#+begin_src emacs-lisp

(defun consult-web-expand-variable-function (var)
"Call the function if VAR is a function"
  (if (functionp var)
                 (funcall var)
    var))
#+end_src
**** http requests
***** backends
****** url retrieve  backend
******* log
#+begin_src emacs-lisp
(defun consult-web--log (string)
  "Logs the response from `consult-web-url-retrieve-sync' in `consult-web-log-buffer-name'."
   (with-current-buffer (get-buffer-create consult-web-log-buffer-name)
     (goto-char (point-min))
     (insert "**********************************************\n")
     (goto-char (point-min))
     (insert (format-time-string "%F - %T%n" (current-time)))
     (insert string)
     (insert "\n")
     (goto-char (point-min))
     (insert "\n\n**********************************************\n")))
#+end_src
******* parse http response
#+begin_src emacs-lisp
(defun consult-web--parse-http-response (&optional buffer)
  "Parse the first header line such as \"HTTP/1.1 200 OK\"."
(with-current-buffer (or buffer (current-buffer))
  (save-excursion
    (goto-char (point-min))
    (when (re-search-forward "\\=[ \t\n]*HTTP/\\(?1:[0-9\\.]+\\) +\\(?2:[0-9]+\\)" url-http-end-of-headers t)
    `(:http-version ,(match-string 1) :code ,(string-to-number (match-string 2)))))))
#+end_src
******* get the response data
#+begin_src emacs-lisp
(defun consult-web--url-response-body (response-data)
"Extracts the response body from `url-retrieve'."
(plist-get response-data :data))
#+end_src

******* error-handler
#+begin_src emacs-lisp
(defun consult-web--url-retrieve-error-handler (&rest args)
  "Handles errors for consult-web-url-retrieve functions."
  (message "consult-web: url-retrieve got an error: %s" (consult-web--parse-http-response)))
#+end_src
******* url retrieve synchronously
#+begin_src emacs-lisp
(cl-defun consult-web--url-retrieve-synchronously (url &rest settings &key params headers parser callback data (type "GET") error (encoding 'utf-8) timeout)
"Retrieves URL synchronously.

Passes all the arguments to url-retriev and fetches the results.

PARAMS are parameters added to the base url using `consult-web--make-url-string'.
HEADERS are headers passed to `url-request-extra-headers'.
DATA are http request data passed to `url-request-data'.
TYPE is the http request type (e.g. “GET”, “POST”)
ERROR
ENCODING
TIMEOUT
PARSER is a function that is executed in the url-retrieve response buffer and the results are returned s the output of this function.
"
  (let* ((url-request-method type)
         (url-request-extra-headers headers)
         (url-request-data data)
         (url-with-params (consult-web--make-url-string url params))
         (url-debug (if consult-web-log-level t nil))
         (response-data nil)
         (buffer (if timeout
                     (with-timeout
                         (timeout
                          (setf response-data (plist-put response-data :status 'timeout))
                          nil)
                       (url-retrieve-synchronously url-with-params t))
                   (url-retrieve-synchronously url-with-params t))
                 ))

    (when buffer
      (add-to-list 'consult-web--hidden-buffers-list buffer)
      (with-current-buffer buffer
        (when consult-web-log-level
          (save-excursion
            (goto-char (point-min))
            (cond
             ((eq consult-web-log-level 'info)
              (consult-web--log (format "URL: %s\nRESPONSE: %s" url (buffer-substring (point-min) (pos-eol)))))
             ((eq consult-web-log-level 'debug)
                 (consult-web--log (format "URL: %s\n\nRESPONSE-HEADER:\n%s\n\nRESPONSE-BODY: %s\n" url (buffer-substring (point-min) url-http-end-of-headers) (buffer-substring url-http-end-of-headers (point-max))))))
            ))

        (let* ((response-header (buffer-substring (point-min) url-http-end-of-headers))
               (response-content (buffer-substring (+ url-http-end-of-headers 1) (point-max)))
               (response-status (consult-web--parse-http-response))
               )
          (delete-region (point-min) (+ url-http-end-of-headers 1))

          (when-let ((parsed-data (funcall parser)))
            (setf response-data (plist-put response-data :data parsed-data))
            )

          (when response-header
            (setf response-data (plist-put response-data :header response-header)))

          (when response-status
            (setf response-data (plist-put response-data :status response-status)))

          (when response-content
            (setf response-data (plist-put response-data :content response-content)))

          )))
    response-data
    ))
#+end_src
******* url retrieve sync
#+begin_src emacs-lisp
(cl-defun consult-web-url-retrieve-sync (url &key params headers parser data (type "GET") error (encoding 'utf-8) timeout)
"Retrieves URL synchronously.

Passes all the arguments to `consult-web--url-retrieve-synchronously'
and in trun to `url-retrieve' to fetch the results synchronously.

TYPE is the http request type (e.g. “GET”, “POST”)
PARAMS are parameters added to the base url using `consult-web--make-url-string'.
HEADERS are headers passed to headers (e.g. `url-request-extra-headers').
DATA are http request data passed to data (e.g. `url-request-data').
PARSER is a function that is executed in the url-retrieve
response buffer and the results are returned s the output of this function.
CALLBACK is the function that is execute when the request is complete.
ERROR is a function that handles errors
ENCODING is the encoding used for the request (e.g. 'utf-8)
TIMEOUT is the time in seconds for timing out the request
"
    (consult-web--url-response-body
     (consult-web--url-retrieve-synchronously url
                                              :params params
                                              :headers headers
                                              :parser parser
                                              :data data
                                              :type type
                                              :error error
                                              :encoding encoding
                                              :timeout (or timeout consult-web-default-timeout))))
#+end_src
******* url retrieve async
#+begin_src emacs-lisp
(cl-defun consult-web-url-retrieve-async (url &rest settings &key params headers parser data (type "GET") callback error (encoding 'utf-8) timeout)
"Retrieves URL synchronously.

Passes all the arguments to url-retrieve
and fetches the results asynchronously.

TYPE is the http request type (e.g. “GET”, “POST”)

PARAMS are parameters added to the base url
using `consult-web--make-url-string'.

HEADERS are headers passed to headers (e.g. `url-request-extra-headers').

DATA are http request data passed to data (e.g. `url-request-data').

PARSER is a function that is executed in the url-retrieve
response buffer and the results are returned s the output of this function.

CALLBACK is the function that is executed when the request is complete.

ERROR is a function that handles errors.

ENCODING is the encoding used for the request (e.g. 'utf-8).

TIMEOUT is the time in seconds for timing out the request.
"
  (let* ((url-request-method type)
         (url-request-extra-headers headers)
         (url-request-data data)
         (url-with-params (consult-web--make-url-string url params))
         (url-debug (if consult-web-log-level t nil))
         (response-data nil)
         (buffer (if timeout
                     (with-timeout
                         (timeout
                          (setf response-data (plist-put response-data :status 'timeout))
                          nil)
                       (url-retrieve url-with-params
                                     (lambda (_)
                                       (when-let* ((attrs (condition-case nil
                                                              (funcall parser)
                                                            (error (funcall error)))))
                                                   (funcall callback attrs))) nil 'silent))
                   (url-retrieve url-with-params
                                 (lambda (_) (let* ((attrs (condition-case nil
                                                              (funcall parser)
                                                            (error (funcall error)))))
                                               (funcall callback attrs))) nil 'silent))
                 ))

    (when buffer
      (add-to-list 'consult-web--hidden-buffers-list buffer)
      (with-current-buffer buffer
        (when consult-web-log-level
          (save-excursion
            (goto-char (point-min))
            (cond
             ((eq consult-web-log-level 'info)
              (consult-web--log (format "URL: %s\nRESPONSE: %s" url (buffer-substring (point-min) (pos-eol)))))
             ((eq consult-web-log-level 'debug)
                 (consult-web--log (format "URL: %s\n\nRESPONSE-HEADER:\n%s\n\nRESPONSE-BODY: %s\n" url (buffer-substring (point-min) url-http-end-of-headers) (buffer-substring url-http-end-of-headers (point-max))))))
            ))
        )
    )))
#+end_src
******* url retrieve
#+begin_src emacs-lisp
(cl-defun consult-web-url-retrieve (url &rest settings &key params headers parser data (sync 'nil) (type "GET") callback error (encoding 'utf-8) timeout)
  "Retrieves URL synchronously.

Passes all the arguments to url-retrieve
and fetches the results asynchronously.

TYPE is the http request type (e.g. “GET”, “POST”)

PARAMS are parameters added to the base url
using `consult-web--make-url-string'.

HEADERS are headers passed to headers (e.g. `url-request-extra-headers').

DATA are http request data passed to data (e.g. `url-request-data').

PARSER is a function that is executed in the url-retrieve
response buffer and the results are returned s the output of this function.

CALLBACK is the function that is executed when the request is complete.

ERROR is a function that handles errors.

ENCODING is the encoding used for the request (e.g. 'utf-8).

TIMEOUT is the time in seconds for timing out the request.
"
  (let* ((url-request-method type)
         (url-request-extra-headers headers)
         (url-request-data data)
         (url-with-params (consult-web--make-url-string url params))
         (url-debug (if consult-web-log-level t nil))
         (response-data nil)
         (buffer (if timeout
                     (with-timeout
                         (timeout
                          (setf response-data (plist-put response-data :status 'timeout))
                          nil)
                       (if sync
                           (url-retrieve-synchronously url-with-params 'silent)
                         (url-retrieve url-with-params
                                       (lambda (_)
                                         (when-let* ((attrs (condition-case nil
                                                                (funcall parser)
                                                              (error (funcall error)))))
                                           (funcall callback attrs))) nil 'silent)))
                   (if sync
                       (url-retrieve-synchronously url-with-params nil 'silent)
                     (url-retrieve url-with-params
                                   (lambda (_) (let* ((attrs (condition-case nil
                                                                 (funcall parser)
                                                               (error (funcall error)))))
                                                 (funcall callback attrs))) nil 'silent)))))
    (when buffer
      (add-to-list 'consult-web--hidden-buffers-list buffer)
      (with-current-buffer buffer
        (when consult-web-log-level
          (save-excursion
            (goto-char (point-min))
            (cond
             ((eq consult-web-log-level 'info)
              (consult-web--log (format "URL: %s\nRESPONSE: %s" url (buffer-substring (point-min) (pos-eol)))))
             ((eq consult-web-log-level 'debug)
              (consult-web--log (format "URL: %s\n\nRESPONSE-HEADER:\n%s\n\nRESPONSE-BODY: %s\n" url (buffer-substring (point-min) url-http-end-of-headers) (buffer-substring url-http-end-of-headers (point-max))))))
            ))
        (if (number-or-marker-p url-http-end-of-headers)
            (delete-region (point-min) (+ url-http-end-of-headers 1)))
        (if sync
            (progn
              (goto-char (point-min))
              (if-let* ((attrs (condition-case nil
                                   (funcall parser)
                                 (error (funcall error)))))
                          (setf response-data (plist-put response-data :data (funcall callback attrs))))))))
        response-data))
#+end_src
****** request backend
******* error-handler
#+begin_src emacs-lisp
(cl-defun consult-web--request-error-handler (&rest args &key symbol-status error-thrown &allow-other-keys)
  "Handles errors for request backend."
  (message "consult-web: <request>  %s - %s" symbol-status error-thrown))
#+end_src
******* consult-web--request-sync
#+begin_src emacs-lisp

  (cl-defun consult-web--request-sync (url &rest args &key params headers data parser placeholder error encoding &allow-other-keys)
    "Convinient wrapper for `request'.

Passes all the arguments to request and fetches the results *synchronously*.

Refer to `request' documents for details."
    (unless (functionp 'request)
      (error "Request backend not available. Either install the package “emacs-request” or change the custom variable `consult-web-retrieve-backend'"))
    (let (candidates)
      (request
        url
        :sync t
        :params params
        :headers headers
        :parser parser
        :error (or error #'consult-web--request-error-handler)
        :data data
        :encoding (or encoding 'utf-8)
        :success (cl-function (lambda (&key data &allow-other-keys)
                                (setq candidates data))))

      candidates))
#+end_src
****** plz
******* error-handler
#+begin_src emacs-lisp
(cl-defun consult-web--plz-error-handler (plz-error &rest args)
  "Handles errors for plz backend."
  (message "consult-web: <plz> %s" plz-error))
#+end_src
***** universal
****** parse buffer
#+begin_src emacs-lisp
(defun consult-web--default-url-parse-buffer ()
""
(let ((end-of-headers (if (and (bound-and-true-p url-http-end-of-headers)
                               (number-or-marker-p url-http-end-of-headers))
                          url-http-end-of-headers
                        (point-min))))
(goto-char end-of-headers)
(json-parse-buffer :object-type 'hash-table :array-type 'list :false-object :false :null-object :null)))
#+end_src
****** fetch url
#+begin_src emacs-lisp
(cl-defun consult-web--fetch-url (url backend &rest args &key type params headers data parser callback error encoding timeout sync &allow-other-keys)
  "Retrieves URL synchronously.

Passes all the arguments to `consult-web--url-retrieve-synchronously' and in trun to `url-retrieve' fetches the results.

TYPE is the http request type (e.g. “GET”, “POST”)
PARAMS are parameters added to the base url using `consult-web--make-url-string'.
HEADERS are headers passed to headers (e.g. `url-request-extra-headers').
DATA are http request data passed to data (e.g. `url-request-data').
PARSER is a function that is executed in the url-retrieve
response buffer and the results are returned s the output of this function.
CALLBACK is the function that is execute when the request is complete.
ERROR is a function that handles errors
ENCODING is the encoding used for the request (e.g. 'utf-8)
TIMEOUT is the time in seconds for timing out the request
"
  (cond
   ((eq backend 'plz)
    (if sync
        (funcall callback (funcall #'plz (or type 'get) (consult-web--make-url-string url params)
                                   :headers headers
                                   :as parser
                                   :then 'sync
                                   :else (or error #'consult-web--plz-error-handler)
                                   :timeout (or timeout consult-web-default-timeout)))
      (funcall #'plz (or type 'get) (consult-web--make-url-string url params)
               :headers headers
               :as parser
               :then callback
               :else (or error #'consult-web--plz-error-handler)
               :timeout (or timeout consult-web-default-timeout))))
   ((eq backend 'url)
    (if sync
        (consult-web--url-response-body
         (funcall #'consult-web-url-retrieve url
                  :sync sync
                  :type (or type "GET")
                  :params params
                  :headers headers
                  :parser parser
                  :data data
                  :error (or error #'consult-web--url-retrieve-error-handler)
                  :callback (or callback #'identity)
                  :encoding (or encoding 'utf-8)
                  :timeout (or timeout consult-web-default-timeout)))
      (funcall #'consult-web-url-retrieve url
               :sync sync
               :type (or type "GET")
               :params params
               :headers headers
               :parser parser
               :data data
               :error (or error #'consult-web--url-retrieve-error-handler)
               :callback (or callback #'identity)
               :encoding (or encoding 'utf-8)
               :timeout (or timeout consult-web-default-timeout))))
   ((eq backend 'request)
    (if sync
        (funcall callback
                 (request-response-data
                  (funcall #'request url
                           :sync sync
                           :params params
                           :headers headers
                           :parser parser
                           :data data
                           :error (or error #'consult-web--request-error-handler)
                           :encoding (or encoding 'utf-8)
                           :timeout (or timeout consult-web-default-timeout)
                           )))
      (funcall #'request url
               :params params
               :headers headers
               :parser parser
               :data data
               :error (or error #'consult-web--request-error-handler)
               :encoding (or encoding 'utf-8)
               :timeout (or timeout consult-web-default-timeout)
               :complete (cl-function (lambda (&key data &allow-other-keys)
                                        (funcall (or callback #'identity) data)))
               ))
    )))
#+end_src
*** consult-web backend
**** kill hidden buffer
#+begin_src emacs-lisp
(defun consult-web--kill-hidden-buffers ()
"Kill all open preview buffers stored in
`consult-gh--preview-buffers-list'.

It asks for confirmation if the buffer is modified
and removes the buffers that are killed from the list."
  (interactive)
  (when consult-web--hidden-buffers-list
    (mapcar (lambda (buff) (if (and (buffer-live-p buff) (not (get-buffer-process buff)))
                             (kill-buffer buff))) consult-web--hidden-buffers-list)
    )
  (setq consult-web--hidden-buffers-list nil)
)
#+end_src

**** kill dead buffers
#+begin_src emacs-lisp
(defun consult-web--kill-dead-buffers ()
"Kill all open preview buffers stored in `consult-gh--preview-buffers-list'.
It asks for confirmation if the buffer is modified and removes the buffers that are killed from the list."
  (interactive)
  (when url-dead-buffer-list
    (mapcar (lambda (buff) (if  (and (buffer-live-p buff) (not (get-buffer-process buff)))
                             (kill-buffer buff))
               ) url-dead-buffer-list)
    )
  (setq url-dead-buffer-list nil)
)
#+end_src

**** get source prop
#+begin_src emacs-lisp
(defun consult-web--get-source-prop (source prop)
(plist-get (cdr (assoc source consult-web-sources-alist)) prop)
)
#+end_src
**** thing at point
#+begin_src emacs-lisp
(defun consult-web-dynamic--split-thingatpt (thing &optional split-initial)
  "Return THING at point.
If SPLIT-INITIAL is non-nil, use `consult--async-split-initial' to format the string."
  (when-let (str (thing-at-point thing t))
    (if split-initial
        (consult--async-split-initial str)
      str)))

#+end_src
**** format / annotate candidates
***** format a single candidate (a.k.a. a hashtable)
****** simple no highlighting and metadata
#+begin_src emacs-lisp

(cl-defun consult-web--simple-format-candidate (&rest args &key source query url search-url title snippet &allow-other-keys)
  "Returns a simple formatted string for candidates.

SOURCE is the name string of the source for candidate

QUERY is the query string used for searching

URL is a string pointing to url of the candidate

SEARCH-URL is a string pointing to the url for
the search results of QUERY on the SOURCE website

TITLE is the title of the candidate

SNIPPET is a string containing a snippet/description of candidate
"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (title-str (consult-web--set-string-width title (* 5 frame-width-percent))))
         (concat title-str
                      (when source (concat "\t" source)))))
#+end_src

****** with highlighted query and searchable metadata
#+begin_src emacs-lisp
(cl-defun consult-web--highlight-format-candidate (&rest args &key source query url search-url title snippet face &allow-other-keys)
  "Returns a highlighted formatted string for candidates.

SOURCE is the name string of the source for candidate

QUERY is the query string used for searching

URL is a string pointing to url of the candidate

SEARCH-URL is a string pointing to the url for
the search results of QUERY on the SOURCE website

TITLE is the title of the candidate

SNIPPET is a string containing a snippet/description of candidate
"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (and (stringp source) (propertize source 'face 'consult-web-source-face)))
         (match-str (and (stringp query) (consult--split-escaped query) nil))
         (face (or (consult-web--get-source-prop source :face) face 'consult-web-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-web--set-string-width title-str (* 4 frame-width-percent)))
         (snippet (and (stringp snippet) (consult-web--set-string-width snippet (* 3 frame-width-percent))))
         (snippet (and (stringp snippet) (propertize snippet 'face 'consult-web-snippet-face)))
         (urlobj (and url (url-generic-parse-url url)))
         (domain (and (url-p urlobj) (url-domain urlobj)))
         (domain (and (stringp domain) (propertize domain 'face 'consult-web-domain-face)))
         (path (and (url-p urlobj) (url-filename urlobj)))
         (path (and (stringp path) (propertize path 'face 'consult-web-path-face)))
         (url-str (consult-web--set-url-width domain path (* frame-width-percent 2)))
         (str (concat title-str
                      (when url-str (concat "\s" url-str))
                      (when snippet (concat "\s\s" snippet))
                      (when source (concat "\t" source)))))
    (if consult-web-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-web--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-web--highlight-match match-str str t)))))
    str))
#+end_src
***** format all candidates in a list  (a.k.a. a list of hashtables)
#+begin_src emacs-lisp
(defun consult-web--format-candidates-list (list &optional format-func face)
"Format a LIST of candidates.

LIST is a list of hashtables, each representing one candidate.
FORMAT-FUNC is a function that is used to format candidates if provided.
Returns a list of formatted candidates using either FORMAT-FUNC or otherwise uses default formating for the source retrieved from `consult-web-sources-alist'."
  (mapcar (lambda (table)
            (let* ((source (gethash :source table))
                  (format-func (or format-func
                         (plist-get (cdr (assoc source consult-web-sources-alist)) :format-func)
                         #'consult-web--table-to-formatted-candidate-searchable))
                  (face (or face
                         (plist-get (cdr (assoc source consult-web-sources-alist)) :face)
                         'consult-web-default-face))
                  )
              (funcall format-func table face))) list))
#+end_src

***** annotate candidates
#+begin_src emacs-lisp
(defun consult-web--annotate-function (cand)
"Annotates each candidate in the minibuffer.

This is provided for convinience to be passed as `:annotate' key when making sources using `consult-web-define-source'.
For more info on annotation refer to `consult' manual, particularly 'consult--read' and `consult--read-annotate' documentation."

    (let* ((url (get-text-property 0 :url cand))
           (urlobj (if url (url-generic-parse-url url)))
           (domain (if (url-p urlobj) (url-domain urlobj) nil))
           (path (if (url-p urlobj) (url-filename urlobj) nil))
           (url-str nil)
           (source (get-text-property 0 :source cand))
           (snippet (get-text-property 0 :snippet cand))
           (extra-args (consult-web-properties-to-plist cand '(:url :source :title :search-url :query :snippet :model :backend))))
      (if domain (setq domain (propertize domain 'face 'consult-web-domain-face)))
      (if path (setq path (propertize path 'face 'consult-web-path-face)))
      (if (and snippet (stringp snippet) (> (length snippet) 25)) (setq snippet (concat (substring snippet 0 22) "...")))
      (setq url-str (concat (if domain domain) (if path path)))
      (unless (string-empty-p url-str) (setq url url-str))
      (when (and url (> (length url) (floor (* (frame-width) 0.4))))
        (setq url (consult-web--set-string-width url (floor (* (frame-width) 0.4)))))
      (concat (if url (format "\s%s" url)) (if source (format "\t%s" source)) (if snippet (format "\s\s%s" snippet)) (if extra-args (format "\t%s" extra-args)))
    ))
#+end_src

**** group candidates based on a keyword

#+begin_src emacs-lisp

(defun consult-web--group-function (sources cand transform &optional group-by)
  "Group candidates by GROUP-BY keyword.

This is passed as GROUP to `consult--read' on candidates and is used to define the grouping for CAND. "
  (if transform (substring cand)
    (let* ((group-by (or consult-web--override-group-by group-by consult-web-group-by))
           (group-by (if (not (keywordp group-by)) (intern (concat ":" (format "%s" group-by))) group-by)))
      (cond
       ((equal group-by :domain)
        (if-let* ((url (get-text-property 0 :url cand))
                  (urlobj (if url (url-generic-parse-url url) nil))
                  (domain (if (url-p urlobj) (url-domain urlobj))))
            domain
          nil))
       ((member group-by '(:nil :none :no :not))
        nil)
       (group-by
        (if-let ((group (get-text-property 0 group-by cand)))
            (format "%s" group)
          "N/A"))
       (t
        (if-let* ((source (plist-get (consult--multi-source sources cand) :name)))
            source
          nil)))
      )))
#+end_src

**** narrowing function (for multi-source commands)

***** single-source narrow
#+begin_src emacs-lisp
(defun consult-web--narrow-function (source)
"Make a narrowing (key . value) pair for the SOURCE string.

key is the first character, and value is the entire source STRING.
For example when “wikipedia” is passed as a source, it returns (w . “wikipedia”)."
 `(,(string-to-char source) . ,source)
)
#+end_src
***** dynamic multi source narrow
#+begin_src emacs-lisp
(defun consult-web--dynamic-narrow-function ()
  "Dynamically makes a list of (key . value) for all the sources in the current list of candidates using `consult-web--narrow-function'."
  (let* ((narrow-pred (lambda (cand)
                       (if-let ((source (get-text-property 0 :source (car cand))))
                         (equal (string-to-char source) consult--narrow)
                           )))
        (narrow-keys (mapcar (lambda (c) (cons (string-to-char c) c))
                              consult-web--current-sources)))
`(:Predicate ,narrow-pred :keys ,narrow-keys)
))
#+end_src
**** lookup function
#+begin_src emacs-lisp
(defun consult-web--lookup-function ()
"Lookup function for `consult-web' minibuffer candidates.

This is passed as LOOKUP to `consult--read' on candidates and is used to format the output when a candidate is selected."
  (lambda (sel cands &rest args)
     (let* ((info (or (car (member sel cands)) ""))
            (title (get-text-property 0 :title info))
            (url (get-text-property 0 :url info))
            )
      (apply #'propertize (or title url "nil") (or (text-properties-at 0 info) (list)))
      )))

#+end_src
**** preview
#+begin_src emacs-lisp
(defun consult-web--default-url-preview (cand)
"Default function to use for previewing CAND."
(when-let* ((url (cond
                  ((listp cand)
                   (or (get-text-property 0 :url (car cand)) (car cand)))
                  (t
                   (or (get-text-property 0 :url cand) cand))))
            (buff (funcall consult-web-default-preview-function url)))
               (funcall (consult--buffer-preview) 'preview
                        buff
                        )
               )
)

#+end_src
**** state
***** make state
#+begin_src emacs-lisp

(cl-defun consult-web--make-state-function (&rest args &key setup preview exit return &allow-other-keys)
"Convinient wrapper for `consult-web' to make custom state functions.

This can be passed as STATE to `consult--read' on candidates and is
used to define actions when setting up, previewing or selecting a
candidate. Refer to `consult--read' documentation for more details."
    (lambda (action cand &rest args)
      (if cand
          (pcase action
            ('setup
             (funcall setup cand))
            ('preview
             (funcall preview cand))
            ('exit
             (funcall exit cand))
            ('return
             (funcall return cand))
             )))
      )

#+end_src
***** dynamic state function
#+begin_src emacs-lisp
(defun consult-web--dynamic-state-function ()
  "State function for `consult-web' minibuffer candidates.

This is passed as STATE to `consult--read' on candidates and is used
to define actions that happen when a candidate is previewed or
selected.
The preview and retrun actions are retrieve from `consult-web-sources-alist'."
  (let ((buffer-preview (consult--buffer-preview)))
    (lambda (action cand &rest args)
      (if cand
          (let* ((source (get-text-property 0 :source cand))
                 (state (plist-get (cdr (assoc source consult-web-sources-alist)) :state))
                 (preview (plist-get (cdr (assoc source consult-web-sources-alist)) :on-preview))
                 (return (plist-get (cdr (assoc source consult-web-sources-alist)) :on-return)))
            (if state
                (funcall state action cand args)
              (pcase action
                ('exit
                 (unless consult-web-log-level
                   (consult-web--kill-hidden-buffers)
                   (consult-web--kill-dead-buffers)
                   )
                 (funcall buffer-preview 'exit cand))
                ('preview
                 (if preview (funcall preview cand) (consult-web--default-url-preview cand)))
                ('return
                 (if return (funcall return cand) cand)))
              ))))))
#+end_src
**** callback
#+begin_src emacs-lisp
(defun consult-web--default-callback (cand)
"Default CALLBACK for CAND.

The CALLBACK is called when a CAND is selected.
When making consult-web sources, if a CALLBACK is not provided, this
CALLBACK is used as a fall back."
  (if-let ((url (get-text-property 0 :url cand)))
      (funcall consult-web-default-browse-function url)))
#+end_src
**** read search string
#+begin_src emacs-lisp
(defun consult-web--read-search-string (&optional initial)
  (consult--read nil
                 :prompt "Search: "
                 :initial initial
                 :category 'consult-web
                 :history 'consult-web--search-history
                 :add-history (delq nil
                                    (cl-remove-duplicates
                                     (append (mapcar (lambda (thing) (consult-web-dynamic--split-thingatpt thing nil))
                                             (list 'number 'word 'sexp 'symbol 'url 'filename 'sentence 'line)) (list isearch-string))))
                                        ))
#+end_src
**** dynamic collection
***** get key value pair from opt
#+begin_src emacs-lisp
(defun consult-web--extract-opt-pair (opt opts ignore-opts)
  "Extracts a pair of (OPT . value) from a list OPTS.

values is the next element after OPT in OPTS.
Excludes keys in IGNORE_OPTS.
This i suseful for example to extract key value pairs
from command-line options in alist of strings"
 (let* ((key (cond
             ((string-match "--.*$" opt)
             (intern (concat ":" (replace-regexp-in-string "--" "" opt))))
             ((string-match ":.*$" opt)
              (intern opt))
             (t nil)))
       (val (or (cadr (member opt opts)) "nil"))
       (val (cond
             ((string-match "--.*$\\|:.*$" val)
              nil)
             ((stringp val)
              (intern val)))))
   (when (and key (not (member opt ignore-opts)))
   (cons key val))
))

#+end_src
***** split args to input and args
#+begin_src emacs-lisp

(defun consult-web--split-args (args)
  "Splits ARGS to remaining args and input
input is the last element of ARGS
remaining args are turned into a plist"
 (pcase-let* ((input (car (last args)))
              (args (seq-difference (remove input args) '((nil nil) (nil)))) ;;this is hacky should find a better way
              (`(,arg . ,opts) (consult--command-split input))
              (remaining-opts (list)))
    (cl-loop for opt in opts
             do
             (pcase-let* ((`(,key . ,val) (consult-web--extract-opt-pair opt opts (list "--group" ":group"))))

        (when key
          (setq args (append args (list key val)))
          (setq remaining-opts (cl-delete-duplicates (append remaining-opts (list opt (format "%s" val))))))
        ))

    (setq opts (seq-difference opts remaining-opts))

    (when (member "-n" opts)
      (setq args (append args `(:count ,(intern (or (nth (+ (cl-position "-n" opts :test 'equal) 1) opts) "nil"))))))

    (when (member "-p" opts)
      (setq args (append args `(:page ,(intern (or (nth (+ (cl-position "-p" opts :test 'equal) 1) opts) "nil")))))
      )

    (if (or (member "-g" opts) (member ":group" opts) (member "--group" opts))
      (cond
       ((member "-g" opts)
        (setq consult-web--override-group-by (intern (or (nth (+ (cl-position "-g" opts :test 'equal) 1) opts) "nil")))
        )
       ((member "--group" opts)
        (setq consult-web--override-group-by (intern (or (nth (+ (cl-position "--group" opts :test 'equal) 1) opts) "nil")))
        )
       ((member ":group" opts)
        (setq consult-web--override-group-by (intern (or (nth (+ (cl-position ":group" opts :test 'equal) 1) opts) "nil")))
        ))
       (setq consult-web--override-group-by nil)
        )
    (list (or arg input) args)
))
#+end_src
***** dynamically get list of candidates from  source(s)
#+begin_src emacs-lisp
(defun consult-web-dynamic--list-from-sources (sources &optional format-func face &rest args)
  "Builds ARGS from user input and collects candidates from all
SOURCES."
  (pcase-let* ((`(,input ,args) (consult-web--split-args args)))
    (cond
     ((and (listp sources))
      (apply 'append
             (cl-loop for source in sources
                      collect
                      (consult-web--format-candidates-list
                       (apply source input args)))))
     ((functionp sources)
      (consult-web--format-candidates-list
       (apply sources input args) format-func face))
     (t
      (error "%s is not a consult-web-source!")))))
#+end_src

***** dynamic collection of results from source(s)
#+begin_src emacs-lisp
(defun consult-web-dynamic--collection (sources &optional format-func face &rest args)
"This is a wrapper using `consult--dynamic-collection' and
`consult-web-dynamic--list-from-sources'."
(consult--dynamic-collection (apply-partially #'consult-web-dynamic--list-from-sources sources format-func face args)))
#+end_src

***** internal read
#+begin_src emacs-lisp
(defun consult-web-dynamic--internal (prompt collection &optional initial category lookup history-var preview-key)
"internal function to run `consult--read'.

PROMPT COLLECTION and INITIAL are passed to `consult--read'."
(consult--read collection
                   :prompt prompt
                   :group (apply-partially #'consult-web--group-function :source)
                   :narrow (consult-web--dynamic-narrow-function)
                   :lookup (or lookup (consult-web--lookup-function))
                   :state (consult-web--dynamic-state-function)
                   :initial (consult--async-split-initial initial)
                   :category (or category 'consult-web)
                   :preview-key (and consult-web-show-preview (or preview-key consult-web-preview-key))
                   :history (cond
                             ((eq history-var t)
                              t)
                             ((eq history-var nil)
                              nil)
                             ((and history-var (symbolp history-var))
                              `(:input ,history-var)))
                   :add-history (delq nil
                                    (cl-remove-duplicates
                                     (append (mapcar (lambda (thing) (consult-web-dynamic--split-thingatpt thing t))
                                             (list 'number 'word 'sexp 'symbol 'url 'filename 'sentence 'line)) (list isearch-string))))
                   :sort t
                   )
)
#+end_src


*** consult-web-multi-static
**** multi-candidates-static
#+begin_src emacs-lisp
(defun consult-web--multi-candidates-static (sources &optional input &rest args)
  "Return `consult--multi' candidates from SOURCES."
  (let* ((candidates (make-vector (length sources) nil))
         (current)
         (idx 0))
    (seq-doseq (src sources)
      (let* ((name (and (plist-member src :name) (plist-get src :name)))
             (face (and (plist-member src :face) `(face ,(plist-get src :face))))
             (cat (plist-get src :category))
             (items (plist-get src :items))
             (narrow (plist-get src :narrow))
             (async-type (and name (consult-web--get-source-prop name :type)))
             (narrow-type (or (car-safe narrow) narrow -1))
             (err (if consult-web-log-level 'err nil))
             )
        (when (or (eq consult--narrow narrow-type)
                  (not (or consult--narrow (plist-get src :hidden))))
          (condition-case err
              (progn
                (when (functionp items)
                  (cond
                   ((and (integerp (cdr (func-arity items))) (< (cdr (func-arity items)) 1))
                    (setq items (funcall items))
                    (aset candidates idx
                          (and items (consult-web--multi-propertize
                                      items cat idx face))))
                   ((eq async-type 'sync)
                    (setq items (funcall items input))
                    (aset candidates idx
                          (and items (consult-web--multi-propertize
                                      items cat idx face))))
                   ((eq async-type 'async)
                    (if input (funcall items input
                                       :callback (lambda (response-items)
                                                   (if response-items
                                                       (setq current
                                                             (and response-items (consult-web--multi-propertize
                                                                                  response-items cat idx face)))
                                                     (setq current t)))
                                       args))
                    (let ((count 0)
                          (max consult-web-default-timeout)
                          (step 0.05))

                      (while (and (< count max) (not current))
                        (+ count step)
                        (if (>= count max)
                            (message "consult-web: Hmmm! %s took longer than expected." (plist-get src :name))
                          (sit-for step)))

                      (aset candidates idx current)))
                   (t
                    (message "source %s needs a :type keyword. See the documentation for `consult-web-define-source'." name)
                    ))))
            ('wrong-type-argument nil)
            ('error
             (message (if consult-web-log-level
                          (format "error in calling :items of %s source - %s" name (error-message-string err))
                        (format "error in calling :items of %s source" name)))
             nil)
            )))
      (cl-incf idx)
      (setq current nil))
    (apply #'append (append candidates nil))))
#+end_src
**** consult-web--multi-static
#+begin_src emacs-lisp
(defun consult-web--multi-static (sources input args &rest options)
  (let* ((sources (consult--multi-enabled-sources sources))
         (candidates (consult--slow-operation "Give me a few seconds. The internet is a big mess!" (consult-web--multi-candidates-static sources input args)))
         (selected
          (apply #'consult--read
                 candidates
                 (append
                  options
                  (list
                   :sort        t
                   :history     'consult-web--selection-history
                   :category    'multi-category
                   :predicate   (apply-partially #'consult-web--multi-predicate sources)
                   :annotate    (apply-partially #'consult-web--multi-annotate sources)
                   :group       (apply-partially #'consult-web--multi-group sources)
                   :lookup      (apply-partially #'consult-web--multi-lookup sources)
                   :preview-key (consult--multi-preview-key sources)
                   :narrow      (consult--multi-narrow sources)
                   :state       (consult--multi-state sources))))))
    (if (plist-member (cdr selected) :match)
        (when-let (fun (plist-get (cdr selected) :new))
          (funcall fun (car selected))
          (plist-put (cdr selected) :match 'new))
      (when-let (fun (plist-get (cdr selected) :action))
        (funcall fun (car selected)))
      (setq selected `(,(car selected) :match t ,@(cdr selected))))
    selected))
#+end_src


*** consult-web-multi-dynamic
**** split-command
#+begin_src emacs-lisp
(defun consult-web--split-command (input &rest args)
  (pcase-let* ((`(,query . ,opts) (consult--command-split input))
               (remaining-opts (list))
               (args (or args (list)))
               )
    (if opts
        (progn
      (cl-loop for opt in opts
               do
               (pcase-let* ((`(,key . ,val) (consult-web--extract-opt-pair opt opts (list "--group" ":group"))))
                 (when key
                   (setq args (append args (list key val)))
                   (setq remaining-opts (cl-delete-duplicates (append remaining-opts (list opt (format "%s" val))))))
                 ))

      (setq opts (seq-difference opts remaining-opts))

      (when (member "-n" opts)
        (setq args (append args `(:count ,(cadr (member "-n" opts))))))

      (when (member "-p" opts)
        (setq args (append args `(:page ,(cadr (member "-p" opts))))))

      (if (or (member "-g" opts) (member ":group" opts) (member "--group" opts))
          (cond
           ((member "-g" opts)
            (setq consult-web--override-group-by (cadr (member "-g" opts))))
           ((member "--group" opts)
            (setq consult-web--override-group-by (cadr (member "--group" opts))))
           ((member ":group" opts)
            (setq consult-web--override-group-by (cadr (member ":group" opts)))))
        (setq consult-web--override-group-by nil)
        ))
      (setq consult-web--override-group-by nil))
    (list (or query input) args)
    ))
#+end_src
**** multi-lookup
#+begin_src emacs-lisp
(defun consult-web--multi-lookup (sources selected candidates _input narrow &rest _)
  "Lookup SELECTED in CANDIDATES given SOURCES, with potential NARROW."
  (if (or (string-blank-p selected)
          (not (consult--tofu-p (aref selected (1- (length selected))))))
      ;; Non-existing candidate without Tofu or default submitted (empty string)
      (let* ((src (cond
                   (narrow (seq-find (lambda (src)
                                       (let ((n (plist-get src :narrow)))
                                         (eq (or (car-safe n) n -1) narrow)))
                                     sources))
                   ((seq-find (lambda (src) (plist-get src :default)) sources))
                   ((seq-find (lambda (src) (not (plist-get src :hidden))) sources))
                   ((aref sources 0))))
             (idx (seq-position sources src))
             (def (and (string-blank-p selected) ;; default candidate
                       (seq-find (lambda (cand) (eq idx (consult--tofu-get cand))) candidates))))
        (if def
            (cons (cdr (get-text-property 0 'multi-category def)) src)
          `(,selected :match nil ,@src)))
    (let* ((found (member selected candidates))
           (info (if found (or (car found) "") ""))
           (title (get-text-property 0 :title info))
           (url (get-text-property 0 :url info))
           )
      (if found
        ;; Existing candidate submitted
        (cons (apply #'propertize (or title url "nil") (or (text-properties-at 0 info) (list)))
              (consult--multi-source sources selected))
      ;; Non-existing Tofu'ed candidate submitted, e.g., via Embark
      `(,(substring selected 0 -1) :match nil ,@(consult--multi-source sources selected))))))

#+end_src
**** muli-group
#+begin_src emacs-lisp
(defun consult-web--multi-group (sources cand transform)
  "Return title of candidate CAND or TRANSFORM the candidate given SOURCES."
  (if transform cand
    (let* ((fun (and (plist-member (consult--multi-source sources cand) :group)
                     (plist-get (consult--multi-source sources cand) :group))))
      (cond
       ((functionp fun)
        (funcall fun sources cand transform))
       ((stringp fun)
        fun)
       ((eq fun 'nil)
        nil)
       (t
        (plist-get (consult--multi-source sources cand) :name))))))
#+end_src
**** multi-predicate
***** multi-predicate
#+begin_src emacs-lisp
(defun consult-web--multi-predicate (sources cand)
  "Predicate function called for each candidate CAND given SOURCES."
  (let* ((src (consult--multi-source sources cand))
         (narrow (plist-get src :narrow))
         (type (or (car-safe narrow) narrow -1))
         (pred (plist-get src :predicate))
         (show t)
         )
    (if pred
        (cond
         ((booleanp pred)
          (setq show pred))
         ((and (functionp pred) (> (car (func-arity pred)) 0))
          (setq show (funcall pred cand)))))
      (and show
           (or (eq consult--narrow type)
               (not (or consult--narrow (plist-get src :hidden)))))))
#+end_src
***** filter by minibuffer content
#+begin_src emacs-lisp
(defun consult-web--match-minibuffer-content-p (cand)
  (let* ((win (active-minibuffer-window))
        (buffer (window-buffer win))
        (split-char (plist-get (consult--async-split-style) :initial)))
  (with-current-buffer buffer
    (if (minibuffer-window-active-p win)
        (string-match (concat ".*" (string-trim (car-safe (consult-web--split-command (minibuffer-contents-no-properties))) split-char "\n") ".*") (substring-no-properties cand))))))
#+end_src
**** multi-enabled
#+begin_src emacs-lisp
(defun consult-web--multi-enabled-sources (sources)
  "Return vector of enabled SOURCES."
  (vconcat
   (seq-filter (lambda (src)
                 (if-let (pred (plist-get src :enabled))
                     (cond
                      ((functionp pred)
                       (funcall pred))
                      ((symbolp pred)
                       pred)
                      (t
                       pred))
                   t))
               (mapcar (lambda (src)
                         (if (symbolp src) (symbol-value src) src))
                       sources))))

#+end_src
**** multi-propertize
#+begin_src emacs-lisp

(defun consult-web--multi-propertize (response-items category pos &optional face)
  "Propertize RESPONSE-ITEMS with the multi-category datum and FACE.

POS and CATEGORY are the group ID and category for these items."
  (let ((annotated-items))
    (dolist (item response-items annotated-items)
      (if (consp item) (setq item (or (car-safe item) item)))
      (let* ((cand (consult--tofu-append item pos)))
        ;; Preserve existing `multi-category' datum of the candidate.
        (if (get-text-property 0 'multi-category cand)
            (when face (add-text-properties 0 (length item) face cand))
          ;; Attach `multi-category' datum and face.
          (add-text-properties 0 (length item)
                               `(multi-category (,category . ,item) ,@face) cand))
        (push cand annotated-items)))))

#+end_src
**** multi-annotate
#+begin_src emacs-lisp

(defun consult-web--multi-annotate (sources cand)
  (let ((src (consult--multi-source sources cand)))
    (if-let ((fun (plist-get src :annotate)))
        (cond
         ((functionp fun)
          (funcall fun (cdr (get-text-property 0 'multi-category cand))))
         ((and (symbolp fun) (functionp (eval fun)))
          (funcall (eval fun) (cdr (get-text-property 0 'multi-category cand)))))
      )))
#+end_src
**** multi-dynamic-candidates-update
#+begin_src emacs-lisp
(defun cosnult-web--multi-dynamic-candidates-update (async sources candidates input &rest args)
    (let ((idx 0))
      (seq-doseq (src sources)
        (let* ((face (and (plist-member src :face) `(face ,(plist-get src :face))))
               (name (plist-get src :name))
               (cat (plist-get src :category))
               (items (plist-get src :items))
               (narrow (plist-get src :narrow))
               (async-type (consult-web--get-source-prop name :type))
               (narrow-type (or (car-safe narrow) narrow -1))
               (err (if consult-web-log-level 'err nil))
               (pos idx))
          (when (or (eq consult--narrow narrow-type)
                    (not (or consult--narrow (plist-get src :hidden))))
            (condition-case err
                (progn
                  (when (functionp items)
                    (cond
                     ((and (integerp (cdr (func-arity items))) (< (cdr (func-arity items)) 1))
                      (setq items (funcall items))
                      (aset candidates idx    ; sync source, refresh now
                            (and items (consult-web--multi-propertize
                                        items cat idx face)))
                      (funcall async 'flush)
                      (funcall async (apply #'append (append candidates nil)))
                      )
                     ((equal async-type 'sync)
                      (setq items (funcall items input args))
                      (aset candidates idx    ; sync source, refresh now
                            (and items (consult-web--multi-propertize
                                        items cat idx face)))
                      (funcall async 'flush)
                      (funcall async (apply #'append (append candidates nil)))
                      )
                     ((equal async-type 'async)
                      (if input (funcall items input      ; async source, refresh in callback
                               :callback (lambda (response-items)
                                 (when response-items
                                   (aset candidates pos
                                         (consult-web--multi-propertize response-items cat pos face))
                                   (funcall async 'flush)
                                   (funcall async (apply #'append (append candidates nil)))
                                   (funcall async 'refresh)
                                   )) args)))
                     (t
                    (message "source %s needs a :type keyword. See the documentation for `consult-web-define-source'." name
                   )))
                    ))
              ('excessive-lisp-nesting nil)
              ('wrong-type-argument nil)
              ('error
               (message (if consult-web-log-level
                            (format "error in calling :items of %s source - %s" name (error-message-string err))
                          (format "error in calling :items of %s source" name)))
             nil)
              )))
        (cl-incf idx))
      candidates))

#+end_src

**** multi-dynamic-compute
#+begin_src emacs-lisp
(defun consult-web--multi-dynamic-compute (async sources &rest args)
  "Dynamic computation of candidates.
ASYNC is the sink.
FUN computes the candidates given the input.
DEBOUNCE is the time after which an interrupted computation
should be restarted."
  (setq async (consult--async-indicator async))
  (let* ((request) (current) (timer)
         (debounce consult-web-dynamic-input-debounce)
         (candidates (make-vector (length sources) nil))
         (cancel (lambda () (when timer (cancel-timer timer) (setq timer nil))))
         (start (lambda (req) (setq request req) (funcall async 'refresh)))
         (fun (apply-partially #'cosnult-web--multi-dynamic-candidates-update async sources))
         )
    (lambda (action)
      (pcase action
        ((and 'nil (guard (not request)))
         (funcall async nil))
        ('nil
         (funcall cancel)
         (let ((state 'killed))
           (unwind-protect
               (progn
                 (funcall async 'indicator 'running)
                 (redisplay)
                 ;; Run computation
                 (let* ((response (funcall fun candidates request args)))
                   ;; Flush and update candidate list
                       (setq candidates response)
                       (if (or (equal response 'nil) (equal response [nil]))
                           (funcall async 'flush)
                         (funcall async 'nil)
                         )
                       (setq state 'finished
                         current request)
                     ))
             (funcall async 'indicator state)
             ;; If the computation was killed, restart it after some time.
             (when (eq state 'killed)
               (setq timer (run-at-time debounce nil start request)))
             (setq request nil))))
        ((pred stringp)
         (funcall cancel)
         (if (or (equal action "") (equal action current))
               (funcall async 'indicator 'finished)
           (funcall start action)
           ))
        ('destroy
         (funcall cancel)
         (funcall async 'destroy))
        (_ (funcall async action))))))

#+end_src
**** multi--sink
#+begin_src emacs-lisp
(defun consult-web--async-sink ()
  "Create ASYNC sink function.

An async function must accept a single action argument.  For the
\\='setup action it is guaranteed that the call originates from
the minibuffer.  For the other actions no assumption about the
context can be made.

\\='setup   Setup the internal closure state.  Return nil.
\\='destroy Destroy the internal closure state.  Return nil.
\\='flush   Flush the list of candidates.  Return nil.
\\='refresh Request UI refresh.  Return nil.
nil      Return the list of candidates.
list     Append the list to the already existing candidates list and return it.
string   Update with the current user input string.  Return nil."
  (let (candidates last buffer)
    (lambda (action)
      (pcase-exhaustive action
        ('setup
         (setq buffer (current-buffer))
         nil)
        ((or (pred stringp) 'destroy) nil)
        ('flush (setq candidates nil last nil))
        ('refresh
         ;; Refresh the UI when the current minibuffer window belongs
         ;; to the current asynchronous completion session.
         (when-let (win (active-minibuffer-window))
           (when (eq (window-buffer win) buffer)
             (with-selected-window win
               (run-hooks 'consult--completion-refresh-hook)
               ;; Interaction between asynchronous completion functions and
               ;; preview: We have to trigger preview immediately when
               ;; candidates arrive (gh:minad/consult#436).
               (when (and consult--preview-function candidates)
                 (funcall consult--preview-function)))))
         nil)
        ('nil candidates)
        ((pred consp)
         (setq last (last (if last (setcdr last action) (setq candidates action))))
         candidates)))))
#+end_src


**** multi-async
#+begin_src emacs-lisp
(defun consult-web--multi-async (async sources)
  "Merge the results of (a)sync SOURCES and pass it to function ASYNC."
  (let ((candidates (make-vector (length sources) nil)))
    (lambda (action)
      (pcase action
        ((pred stringp)
         (unless (equal action "")
           (let ((idx 0))
             (seq-doseq (src sources)
               (let* ((face (and (plist-member src :face) `(face ,(plist-get src :face))))
                      (cat (plist-get src :category))
                      (items (plist-get src :items))
                      (narrow (plist-get src :narrow))
                      (type (or (car-safe narrow) narrow -1))
                      (pos idx))
                 (when (or (eq consult--narrow type)
                           (not (or consult--narrow (plist-get src :hidden))))
                   (condition-case nil
                       (progn
                         (when (functionp items)
                           (cond
                            ((and (integerp (cdr (func-arity items))) (< (cdr (func-arity items)) 1))
                             (setq items (funcall items))
                             (aset candidates idx    ; sync source, refresh now
                               (and items (consult-web--multi-propertize
                                           items cat idx face)))
                             (funcall async 'flush)
                             (funcall async (apply #'append (append candidates nil))))
                            ((and (integerp (cdr (func-arity items))) (< (cdr (func-arity items)) 2))
                             (setq items (funcall items action))
                             (aset candidates idx    ; sync source, refresh now
                                   (and items (consult-web--multi-propertize
                                               items cat idx face)))
                             (funcall async 'flush)
                             (funcall async (apply #'append (append candidates nil))))
                            ((and (integerp (cdr (func-arity items))) (< (cdr (func-arity items)) 3))
                             (funcall items action      ; async source, refresh in callback
                               (lambda (response-items)
                                 (when response-items
                                   (aset candidates pos
                                         (consult-web--multi-propertize response-items cat pos face))
                                   (funcall async 'flush)
                                   (funcall async (apply #'append (append candidates nil))))))))
                            ))
                     (t
                      (message "calling :items in %s source produced error" src))
                     )))
               (cl-incf idx)))))
        (_ (funcall async action))))))
#+end_src

**** dynamic collection
#+begin_src emacs-lisp
(defun consult-web--multi-dynamic-collection (sources &rest args)
(thread-first
  (consult--async-sink)
  (consult-web--multi-dynamic-compute sources)
  (consult--async-throttle)
  (consult--async-split)))
#+end_src
**** consult-web--multi
#+begin_src emacs-lisp
(cl-defun consult-web--multi-dynamic (sources args &rest options)
  (let* ((sources (consult-web--multi-enabled-sources sources))
         (selected
          (apply #'consult--read
                 (consult-web--multi-dynamic-collection sources args)
                 (append
                  options
                  (list
                   :sort        t
                   :history     'consult-web--search-history
                   :initial     (consult--async-split-initial nil)
                   :category    'multi-category
                   :predicate   (apply-partially #'consult-web--multi-predicate sources)
                   :annotate    (apply-partially #'consult-web--multi-annotate sources)
                   :group       (apply-partially #'consult-web--multi-group sources)
                   :lookup      (apply-partially #'consult-web--multi-lookup sources)
                   :preview-key (consult--multi-preview-key sources)
                   :narrow      (consult--multi-narrow sources)
                   :state       (consult--multi-state sources))))))
    (if (plist-member (cdr selected) :match)
        (when-let (fun (plist-get (cdr selected) :new))
          (funcall fun (car selected))
          (plist-put (cdr selected) :match 'new))
      (when-let (fun (plist-get (cdr selected) :action))
        (funcall fun (car selected)))
      (setq selected `(,(car selected) :match t ,@(cdr selected))))
    selected))
#+end_src
** Macro
*** make a variable for source
**** make symbol for source name
#+begin_src emacs-lisp
(defun consult-web--source-name (source-name &optional suffix)
  "Returns a symbol for SOURCE-NAME variable.

The variable is consult-web--source-%s (%s=source-name).
Adds suffix to the name if provided."
  (intern (format "consult-web--source-%s" (concat (replace-regexp-in-string " " "-" (downcase source-name)) (if suffix (downcase suffix) nil)))))

#+end_src
**** make generic docstring for varibale of source
#+begin_src emacs-lisp

(defun consult-web--source-generate-docstring (source-name)
  "Makes a generic documentation string for SOURCE-NAME.

This is used in `consult-web-define-source' macro to make generic
docstrings for variables."
  (format "consult-web source for %s.\n \nThis function was defined by the macro `consult-web-define-source'."
          (capitalize source-name)))
#+end_src
*** make a function for source
**** make a function symbol for source
#+begin_src emacs-lisp

(defun consult-web--func-name (source-name &optional prefix suffix)
  "Make a function symbol for interactive command for SOURCE-NAME.

Adds prefix and suffix if non-nil."
  (intern (concat "consult-web-" (if prefix prefix) (replace-regexp-in-string " " "-" (downcase source-name)) (if suffix suffix))))
#+end_src
**** make generic doctring for function of source
#+begin_src emacs-lisp

(defun consult-web--func-generate-docstring (source-name &optional dynamic)
  "Make a generic documentaion string for an interactive command.

This is used to make docstring for function made by `consult-web-define-source'."
  (concat "consult-web's " (if dynamic "dynamic ") (format "interactive command to search %s."
                                                             (capitalize source-name))))
#+end_src
*** make a consult--read source list
#+begin_src emacs-lisp
(defun consult-web--make-source-list (source-name request format annotate face narrow-char state preview-key category lookup group sort enabled predicate selection-history)
  "Internal function to make a source for `consult--multi'.

Do not use this function directly, use `consult-web-define-source' macro
instead."
  `(:name ,source-name
          ,(when (and annotate face) :face)
          ,(when (and annotate face) (cond
            ((eq face t)
             'consult-web-default-face)
            (t face)))
          :narrow ,narrow-char
          :state ,(or state #'consult-web--dynamic-state-function)
          :category ,(or category 'consult-web)
          :history ,selection-history
          :add-history (delq nil
                                    (cl-remove-duplicates
                                     (append (mapcar (lambda (thing) (consult-web-dynamic--split-thingatpt thing))
                                             (list 'number 'word 'sexp 'symbol 'url 'filename 'sentence 'line)) (list isearch-string))))
          :items  ,request
          :annotate ,(cond
                      ((and annotate (functionp annotate))
                       annotate)
                      ((eq annotate t)
                       #'consult-web--annotate-function)
                      (t nil))
          :lookup ,(if (and lookup (functionp lookup))
                      lookup
                    (consult-web--lookup-function))
          :group ,(or group #'consult-web--group-function)
          :preview-key ,(and consult-web-show-preview (or preview-key consult-web-preview-key))
          ,(when enabled ':enabled)
          ,(when enabled enabled)
          :sort ,sort
          ,(when predicate ':predicate)
          ,(when predicate predicate)
          ))
#+end_src
*** make a static interactive command
#+begin_src emacs-lisp

(defun consult-web--call-static-command (input no-callback args request format face state source-name category lookup selection-history-var annotate preview-key sort)
  "Internal function to make static `consult--read' command.

Do not use this function directly, use `consult-web-define-source' macro
instead."
  (let* ((input (or input
                    (and consult-web-default-autosuggest-command (funcall-interactively consult-web-default-autosuggest-command))
                    (consult-web--read-search-string)))

         (prompt (concat "[" (propertize (format "%s" (consult-web--func-name source-name)) 'face 'consult-web-prompt-face) "]" " Search: "))
         (selected (consult-web--multi-static (list (consult-web--source-name source-name))
                                              input
                                              args
                                              :prompt prompt
                                              :sort sort
                                              :history selection-history-var))
         (selected (cond
                    ((consp selected) (car-safe selected))
                    (t selected)))
         (source (get-text-property 0 :source selected))
         )
    (unless no-callback
      (if source
          (funcall (plist-get (cdr (assoc source consult-web-sources-alist)) :on-callback) selected)))
    selected)
  )

#+end_src
*** make a dynamic interactive command
#+begin_src emacs-lisp
(defun consult-web--call-dynamic-command (initial no-callback args source-name request category face lookup search-history-var selection-history-var preview-key sort)
  "Internal function to make dynamic `consult--read' command.

Do not use this function directly, use `consult-web-define-source' macro
 instead."
  (let* ((consult-async-refresh-delay consult-web-dynamic-refresh-delay)
         (consult-async-input-throttle consult-web-dynamic-input-throttle)
         (consult-async-input-debounce consult-web-dynamic-input-debounce)
         (prompt (concat "[" (propertize (format "%s" (consult-web--func-name source-name)) 'face 'consult-web-prompt-face) "]" " Search: "))
         (selected (consult-web--multi-dynamic (list (consult-web--source-name source-name))
                                               args
                                      :prompt prompt
                                      :history '(:input search-history-var)
                                      :initial (consult--async-split-initial initial)
                                      :sort sort
                                      ))
         (selected (cond
                    ((consp selected) (car selected))
                    (t selected)))
         (source (get-text-property 0 :source selected))
         (title (get-text-property 0 :title selected)))
    (add-to-history selection-history-var title)
    (unless no-callback
      (funcall (plist-get (cdr (assoc source consult-web-sources-alist)) :on-callback) selected)
      )
    selected
    ))
#+end_src
*** macro to add a new source
#+begin_src emacs-lisp
;;; Macros
;;;###autoload
(cl-defmacro consult-web-define-source (source-name &rest args &key type request format on-preview on-return state on-callback lookup dynamic group narrow-char category search-history selection-history face annotate preview-key docstring enabled sort predicate &allow-other-keys)
  "Macro to make a consult-web-source for SOURCE-NAME.

\* Makes
- source for `consult-web-multi' and/or `consult-web-dynamic'
- interactive commands (static or dynamic) for single source
- adds a new row to to `consult-web-sources-alist' with all the
metadata as a property list.

\* Keyword Arguments

Brief Description:

==========  ==========      =================================================
Keyword     Type            Explanation
==========  ==========      =================================================

REQUEST     (function)      Fetch results from source

FORMAT      (function)      Formats a single candidate

ON-PREVIEW  (function)      Preview action in `consult--read'

ON-RETURN   (function)      Return action in `consult--read'

STATE       (function)      STATE passed to `consult--read'
                            (bypasses ON-PREVIEW and ON-RETURN)

ON-CALLBACK (function)      Function called on selected candidate

DYNAMIC     (boolean/'both) Whether to make dynamic or non-dynamic commands

GROUP       (function)      Passed as GROUP to `consult--read'

ANNOTATE    (function)      Passed as ANNOTATE to `consult--read'

NARROW-CHAR (char)          Ppassed as NARROW to `consult-read'

CATEGORY    (symbol)        Passed as CATEGORY to `consult--read'

HISTORY     (symbol)        Passed as HISTORY to `consult--read'

FACE        (face)          Passed as FACE to `consult--read-multi'

PREVIEW-KEY (key)           Passed as PREVIEW-KEY to `consult--read'

DOCSTRING   (string)        DOCSTRING for the variable created for SOURCE-NAME

===================================================================

Detailed Decription:

REQUEST is a function that takes at least one string argument, INPUT, which is
the search term, and potentially other arguments. Keyword arguments
(e.g. by using `cl-defun') can be passed to this function from
minibuffer prompt using
`consult-async' commandline arguments.
Examples can be found in the wiki pages of the repo or in
“consult-web-sources.el” on the repository webpage or :
URL `https://github.com/armindarvish/consult-web/blob/main/consult-web-sources.el'


FORMAT takes a hashtable and returns a cons with a propertized string as key
 and plist property as value. For an example see
`consult-web--table-to-formatted-candidate-simple' or `consult-web--table-to-formatted-candidate-searchable'.

ON-PREVIEW is used as a function to call on the candidate, when a preview is
requested. It takes one required argument, the candidate. For an example,
see `consult-web-default-preview-function'.

ON-RETURN is used as a function to call on the candidate, when the
candidate is selected. This is passed to consult built-in state
function machinery.
Note that the output of this function will be returned in the consult-web
commands. In consult-web, ON-CALLBACK is used to call further actions on
this returned value. This allows to separate the return value from the
commands and the action that i run on the selected candidates. Therefore
for most use cases, ON-RETURN can just be `#'identity' to get
the candidate back as it is. But if some transformation is needed,
ON-RETURN can be used to transform the selected candidate.


STATE is a function that takes no argument and returns a function for
consult--read STATE argument. For an example see
`consult-web--dynamic-state-function' that builds state function based on
 ON-PREVIEW and ON-RETURN. If STATE is non-nil, instead of using
ON-PREVIEW and ON-RETURN to make a state function, STATE will be directly
used in consult--read.


ON-CALLBACK is the function that is called with one required input argument,
 the selected candidate. For example, see `consult-web--default-callback'
that opens the url of the candidate in the default browser.
Other examples can be found in the wiki pages of the repo or in
“consult-web-sources.el” on the repository webpage or :
URL `https://github.com/armindarvish/consult-web/blob/main/consult-web-sources.el'

DYNAMIC can be a bollean (nil or t) or the symbol 'both.
If nil only \*non-dynamic\* interactive commands are created in this macro.
if t only \*dynamic\* interactive commands are created in this macro.
If something else (e.g. 'both) \*Both\* dynamic and non-dynamic commands
are created.

GROUP, ANNOTATE, NARROW-CHAR, CATEGORY, and PREVIEW-KEY are passed to
`consult--read' or `consult--multi'. See consult's Documentaion for more
 details.

FACE is passed to `consult-multi'. See consult's Documentaion for more
details.


DOCSTRING is used as docstring for the variable consult-web--source-%s
variable that this macro creates for %s=SOURCE-NAME.
"
  (if (symbolp source-name) (setq source-name (eval source-name)))

  `(progn

     ;; make a variable called consult-web--source-%s (%s=source-name)
     (defvar ,(consult-web--source-name source-name) (consult-web--make-source-list ,source-name ,request ,format ,annotate ,face ,narrow-char ,state ,preview-key ,category ,lookup ,group ,sort ,enabled ,predicate ,selection-history))

     ;; make a static interactive command consult-web-%s (%s=source-name)
     (unless (eq ,dynamic t)
       (defun ,(consult-web--func-name source-name nil "-static") (&optional input no-callback &rest args)
         ,(or docstring (consult-web--func-generate-docstring source-name))
         (interactive "P")
         (consult-web--call-static-command input no-callback args ,request ,format ,face ,state ,source-name ,category ,lookup ,selection-history ,annotate ,preview-key ,sort)
         ))

     ;; make a dynamic interactive command consult-web-dynamic-%s (%s=source-name)
     (if ,dynamic
         (defun ,(consult-web--func-name source-name) (&optional initial no-callback &rest args)
           ,(or docstring (consult-web--func-generate-docstring source-name t))
           (interactive "P")
           (consult-web--call-dynamic-command initial no-callback args ,source-name ,request ,category ,face ,lookup ,search-history ,selection-history ,preview-key ,sort)
           ))

     ;; add source to consult-web-sources-alist
     (add-to-list 'consult-web-sources-alist (cons ,source-name
                                                          (list :name ,source-name
                                                                :source (consult-web--source-name ,source-name)
                                                                :face ,face
                                                                :request-func ,request
                                                                :format-func (or ,format #'consult-web--table-to-formatted-candidate-searchable)


                                                                :on-preview (or ,on-preview #'consult-web--default-url-preview)
                                                                :on-return (or ,on-return #'identity)
                                                                :on-callback (or ,on-callback #'consult-web--default-callback)
                                                                :state ,state
                                                                :group ,group
                                                                :annotate ,annotate
                                                                :narrow-char ,narrow-char
                                                                :preview-key ,preview-key
                                                                :category (or ',category 'consult-web)
                                                                :search-history ,search-history
                                                                :selection-history ,selection-history
                                                                :interactive-static (and (functionp (consult-web--func-name ,source-name)) (consult-web--func-name ,source-name))
                                                                :interactive-dynamic (and (functionp (consult-web--func-name ,source-name "dynamic-")) (consult-web--func-name ,source-name "dynamic-"))
                                                                :enabled ,enabled
                                                                :sort ,sort
                                                                :type ,type
                                                                )))

     ,source-name))

#+end_src
*** make source for consult-web from consult source
**** make fetch function
#+begin_src emacs-lisp
;;;###autoload
(cl-defmacro consult-web--make-fetch-function (source &rest args &key source-name docstring &allow-other-keys)
  "Make a function for fetching result based on SOURCE.

SOURCE is a source for consult (e.g. a plist that is passed
to consult--multi). See `consult-buffer-sources' for examples.
SOURCE-NAME is a string name for SOURCE
DOCSTRING is the docstring for the function that is returned."
  (let* ((source (if (plistp source) source (eval source)))
        (source-name (substring-no-properties (plist-get source :name))))
  `(progn
     ;; make a function that creates a consult--read source for consult-web-multi
     (cl-defun ,(consult-web--source-name source-name "-fetch-results") (input &rest args &key callback &allow-other-keys)
       ,(or docstring (consult-web--source-generate-docstring source-name))
  (pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
         (opts (car-safe opts))
         (fun  (plist-get ',source :items))
         (results (cond
                   ((functionp fun) (funcall fun))
                   ((listp fun) fun)
                   ))
         (source (substring-no-properties (plist-get ',source :name))))
    (delq nil (mapcar (lambda (item)
                        (if (consp item) (setq item (or (car-safe item) item)))
              (when (string-match (concat ".*" query ".*") item)
                  (propertize item
                              :source source
                              :title item
                              :url nil
                              :query query
                              :search-url nil
                              ))) results)))))))
#+end_src
**** define source
#+begin_src emacs-lisp

(cl-defun consult-web--make-source-from-consult-source (consult-source &rest args &key type request format on-preview on-return state on-callback group narrow-char category dynamic search-history selection-history face annotate enabled sort predicate preview-key docstring &allow-other-keys)
"Makes a consult-web source from a consult source, CONSULT-SOURCE.
All othe input variables are passed to `consult-web-define-source'
macro. See `consult-web-define-source' for more details"
  (if (boundp consult-source)
        (let* ((source (eval consult-source))
               (source (if (plistp source) source (eval source)))
               (name (and (plistp source) (substring-no-properties (plist-get source :name))))
               (narrow-char (or narrow-char (and (plistp source) (plist-get source :narrow))))
               (narrow-char (if (listp narrow-char) (car narrow-char)))
               (face (or face (and (plistp source) (plist-get source :face))))
               (state (or state (and (plistp source) (plist-get source :state))))
               (annotate (cond
                          ((eq annotate 'nil) nil)
                          ((eq annotate 't) (and (plistp source) (plist-get source :annotate)))
                          (t annotate)))
               (preview-key (or preview-key (and (plistp source) (plist-get source :preview-key)) consult-web-preview-key))
               (predicate (or predicate (and (plistp source) (plist-get source :predicate))))
               (group (or group (and (plistp source) (plist-get source :group))))
               (sort (or sort (and (plistp source) (plist-get source :sort))))
               (enabled (or enabled (and (plistp source) (plist-get source :enabled))))
               (category (or category (and (plistp source) (plist-get source :category)) 'consult-web)))
          (eval (macroexpand
           `(consult-web-define-source ,name
                                     :docstring ,docstring
                                     :narrow-char ,narrow-char
                                     :type ',type
                                     :face ',face
                                     :category ',category
                                     :request (or ,request (consult-web--make-fetch-function ,source))
                                     :preview-key ,preview-key
                                     :search-history ',search-history
                                     :selection-history ',selection-history
                                     :on-preview ',on-preview
                                     :on-return ',on-return
                                     :on-callback ',on-callback
                                     :enabled ',enabled
                                     :predicate ',predicate
                                     :group ',group
                                     :sort ',sort
                                     :dynamic ',dynamic
                                     :annotate ',annotate
                                     ))))
    (display-warning :warning (format "Consult-web: %s is not available. Make sure `consult-notes' is loaded and set up properly" consult-source)))
  )
#+end_src
** Frontend Interactive commands
*** consult-web-multi
**** interactive
#+begin_src emacs-lisp
;;; Frontend Interactive Commands
(defun consult-web-multi (&optional initial sources no-callback &rest args)
"Interactive “multi-source dynamic search”

INITIAL is the initial search prompt in minibuffer.
Searches all sources in SOURCES. if SOURCES is nil
`consult-web-dynamic-sources' is used.
If NO-CALLBACK is t, only the selected candidate is returned without
any callback action.

This is an interactive command that fetches results form all the sources in `consult-web-dynamic-sources' with dynamic completion meaning that the search term can be dynamically updated by the user
and the results are fetched as the user types.

Additional commandline arguments can be passed in the minibuffer
entry similar to `consult-grep' by typing `--` followed by arguments.

For example the user can enter:

`#consult-web -- -g domain'

this will run a search on all the `consult-web-dynamic-sources' for
the term “consult-web” and then groups the results by the “domain
of the URL” of the results.

Built-in arguments include:

 -g, --groups, or :groups  for grouping (see `consult-web-group-by' and `consult-web--override-group-by'. for more info)

 -n, --count, or :count is passed as the value for COUNT to any source in `consult-web-dynamic-sources'.
If the request function for the source takes a keyword argument for COUNT (e.g. :count value), this is used as the value otherwise it is ignored.

 -p, --page, or :page is passed as the value for PAGE to any source in `consult-web-dynamic-sources'.
If the request function for the source takes a keyword argument for page (e.g. :page value), this is used as the value otherwise it is ignored.

Custom arguments can be passed by using “--ARG value” (or “:ARG value”).
For example, if the user types the following in the minibuffer:
“#how to do web search in emacs? -- --model gpt-4”
The term “how to do web search in emacs?” is passed as the search
term and the “gpt-4” as a keyword argument for :model to every
source in `consult-web-dynamic-sources'. If any request function of
the sources takes a keyword argument for :model, “gpt-4” is
used then.

Once the results are fetched, narrowing down can be done by using “#” after the serach term similar to `consult-grep'.
For example:
“#consult-web#github.com”
uses “consult-web” as the search term, and then narrows the choices to
results that have “github.com” in them.

For more examples, refer to the official documentation of the repo here:
URL `https://github.com/armindarvish/consult-web'.

For more details on consult--async functionalities, see `consult-grep'
and the official manual of consult, here: URL `https://github.com/minad/consult'."
  (interactive "P")
  (let* ((input (or input
                    (and consult-web-default-autosuggest-command (funcall-interactively consult-web-default-autosuggest-command))
                    (consult-web--read-search-string)))
         (sources (or sources consult-web-multi-sources))
         (sources (remove nil (mapcar (lambda (source) (plist-get (cdr (assoc source consult-web-sources-alist)) :source)) sources)))
         (candidates (consult--slow-operation "The web is a big place, allow me a few seconds..." (mapcar (lambda (func) (funcall func input args)) sources)))
         (selected (consult--multi candidates
                                   :require-match nil
                                   :prompt (concat "[" (propertize "consult-web-multi" 'face 'consult-web-prompt-face) "]" " Search:  ")
                                   :sort t
                                   :annotate nil
                                   :category 'consult-web
                                   :history 'consult-web--selection-history
                                   ))
         (source (get-text-property 0 :source (car selected)))
         )
    (unless no-callback
      (funcall (plist-get (cdr (assoc source consult-web-sources-alist)) :on-callback) (car selected)))
    (car selected)
    ))


(defun consult-web-multi (&optional initial sources no-callback &rest args)
  (interactive "P")
  (let* ((consult-async-refresh-delay consult-web-dynamic-refresh-delay)
         (consult-async-input-throttle consult-web-dynamic-input-throttle)
         (consult-async-input-debounce consult-web-dynamic-input-debounce)
         (sources (or sources consult-web-dynamic-sources))
         (sources (remove nil (mapcar (lambda (source) (plist-get (cdr (assoc source consult-web-sources-alist)) :source)) sources)))
         (prompt (concat "[" (propertize "consult-web-multi" 'face 'consult-web-prompt-face) "]" " Search:  "))
         (selected
          (car-safe (consult-web--multi-dynamic
                     sources
                     args
                     :prompt prompt
                     :sort t
                     :history '(:input consult-web--search-history)
                     :initial (consult--async-split-initial initial)
                     )))
         (source (get-text-property 0 :source selected)))
    (funcall (plist-get (cdr (assoc source consult-web-sources-alist)) :on-callback) selected)
    selected
    ))

#+end_src
*** consult-web-sync
**** interactive
#+begin_src emacs-lisp
(defun consult-web-sync (&optional input sources no-callback &rest args)
  "Interactive “synchronous” multi-source search

INPUT is the initial search query.
Searches all sources in SOURCES. if SOURCES is nil
`consult-web-multi-sources' is used.
If NO-CALLBACK is t, only the selected candidate is returned without
any callback action.
"
  (interactive "P")
  (let* ((input (or input
                    (and consult-web-default-autosuggest-command (funcall-interactively consult-web-default-autosuggest-command))
                    (consult-web--read-search-string)))
         (sources (or sources consult-web-multi-sources))
         (sources (remove nil (mapcar (lambda (source) (plist-get (cdr (assoc source consult-web-sources-alist)) :source)) sources)))
         (prompt (concat "[" (propertize "consult-web-sync" 'face 'consult-web-prompt-face) "]" " Search:  "))
         (selected
          (car-safe (consult-web--multi-static sources
                                               input
                                               nil
                                               :prompt prompt
                                               :history 'consult-web--selection-history
                                               :sort t
                                               )))
         (source (get-text-property 0 :source selected)))
        (unless no-callback
          (funcall (plist-get (cdr (assoc source consult-web-sources-alist)) :on-callback) selected))
    selected
    ))
#+end_src
*** consult-web-scholar
**** interactive
#+begin_src emacs-lisp
(defun consult-web-scholar (&optional initial sources no-callback &rest args)
  "Interactive “multi-source acadmic literature” search

INITIAL is the initial search prompt in minibuffer.
Searches all sources in SOURCES. if SOURCES is nil
`consult-web-scholar-sources' is used.
If NO-CALLBACK is t, only the selected candidate is returned without
any callback action.

This is similar to `consult-web-multi', but runs the search on academic literature sources in `consult-web-scholar-sources'.
Refer to `consult-web-multi' for more details."
  (interactive "P")
  (let* ((consult-async-refresh-delay consult-web-dynamic-refresh-delay)
         (consult-async-input-throttle consult-web-dynamic-input-throttle)
         (consult-async-input-debounce consult-web-dynamic-input-debounce)
         (sources (or sources consult-web-scholar-sources))
         (sources (remove nil (mapcar (lambda (source) (plist-get (cdr (assoc source consult-web-sources-alist)) :source)) sources)))
         (prompt (concat "[" (propertize "consult-web-scholar" 'face 'consult-web-prompt-face) "]" " Search:  "))
         (selected
          (car-safe (consult-web--multi-dynamic
                     sources
                     args
                     :prompt prompt
                     :sort t
                     :history '(:input consult-web--search-history)
                     :initial (consult--async-split-initial initial)
                     )))
         (source (get-text-property 0 :source selected)))
    (funcall (plist-get (cdr (assoc source consult-web-sources-alist)) :on-callback) selected)
    selected
    ))
#+end_src
*** consult-web-dynamic-omni
**** interactive
#+begin_src emacs-lisp
(defun consult-web-omni (&optional initial sources no-callback &rest args)
  "Interactive “multi-source and async omni search”
This is for using combination of web and local sources defined in
`consult-web-omni-sources'.

INITIAL is the initial search prompt in minibuffer.
Searches all sources in SOURCES. if SOURCES is nil
`consult-web-omni-sources' is used.
If NO-CALLBACK is t, only the selected candidate is returned without
any callback action.

This is a dynamic command and additional arguments can be passed in
the minibuffer. See `consult-web-multi' for more details."

  (interactive "P")
  (let* ((consult-async-refresh-delay consult-web-dynamic-refresh-delay)
         (consult-async-input-throttle consult-web-dynamic-input-throttle)
         (consult-async-input-debounce consult-web-dynamic-input-debounce)
         (sources (or sources consult-web-omni-sources))
         (sources (remove nil (mapcar (lambda (source) (plist-get (cdr (assoc source consult-web-sources-alist)) :source)) sources)))
         (prompt (concat "[" (propertize "consult-web-omni" 'face 'consult-web-prompt-face) "]" " Search:  "))
         (selected
          (car-safe (consult-web--multi-dynamic
                     sources
                     args
                     :prompt prompt
                     :sort t
                     :history '(:input consult-web--search-history)
                     :initial (consult--async-split-initial initial)
                     )))
         (source (get-text-property 0 :source selected)))
    (funcall (plist-get (cdr (assoc source consult-web-sources-alist)) :on-callback) selected)
    selected
    ))
#+end_src
*** consult-web
#+begin_src emacs-lisp
(defun consult-web (&rest args)
"Wrapper function that calls the function in `consult-web-default-interactive-command'.

This is for conviniece to call the favorite consult-web interactive command."
  (interactive)
  (apply consult-web-default-interactive-command args))
#+end_src
** Provide and Footer
#+begin_src emacs-lisp
;;; provide `consult-web' module

(provide 'consult-web)

;;; consult-web.el ends here
#+end_src

* embark
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./consult-web-embark.el
:END:
** Header
#+begin_src emacs-lisp
;;; consult-web-embark.el --- Emabrk Actions for `consult-web' -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish


;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "27.1") (consult "0.34") (consult-web 0.1))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:
#+end_src
** Requirements
#+begin_src emacs-lisp
;;; Requirements

(require 'embark)
(require 'consult-web)

#+end_src
** General
*** actions
#+begin_src emacs-lisp
;;; Define Embark Action Functions

(defun consult-web-embark-default-action (cand)
  "Calls the default action on CAND.

Gets the default callback function from `consult-web-sources-alist'."
  (let* ((source (and (stringp cand) (get-text-property 0 :source cand))))
    (funcall (plist-get (cdr (assoc source consult-web-sources-alist)) :on-callback) cand))
  )

(add-to-list 'embark-default-action-overrides '(consult-web . consult-web-embark-default-action))


(defun consult-web-embark-insert-title (cand)
  "Insert the title oif the candidate at point"
  (if-let ((title (and (stringp cand) (get-text-property 0 :title cand))))
      (insert (format " %s " title))))

(defun consult-web-embark-copy-title-as-kill (cand)
  "Copy the title of the candidate to `kill-ring'."
  (if-let ((title (and (stringp cand) (get-text-property 0 :title cand))))
      (kill-new (string-trim title))))

(defun consult-web-embark-insert-url-link (cand)
  "Insert the title oif the candidate at point."
  (let* ((url (and (stringp cand) (get-text-property 0 :url cand)))
         (url (and (stringp url) (string-trim url)))
         (title (and (stringp cand) (get-text-property 0 :title cand))))
    (when url
      (cond
       ((derived-mode-p 'org-mode)
        (insert (cond
                 ((and url title) (format " [[%s][%s]] " url title))
                 (url (format " [[%s]] " url))
                 (t ""))
                ))
       ((derived-mode-p 'markdown-mode)
        (insert (cond
                 ((and url title) (format " [%s](%s) " url title))
                 (url (format " <%s> " url))
                 (t ""))
                ))
       (t
        (insert (cond
                 ((and url title) (format " %s (%s) " title  url))
                 (url (format " %s " url))
                 (t ""))
                ))))))

(defun consult-web-embark-copy-url-as-kill (cand)
  "Copy the url of the candidate to `kill-ring'."
  (if-let ((url (and (stringp cand) (get-text-property 0 :url cand))))
      (kill-new (format " %s " (string-trim url)))
    ))

(defun consult-web-embark-external-browse-link (cand)
  "Open the url with `consult-web-default-browse-function'"
  (if-let* ((url (and (stringp cand) (get-text-property 0 :url cand))))
      (funcall consult-web-default-browse-function url)))

(defun consult-web-embark-alternate-browse-link (cand)
  "Open the url with `consult-web-alternate-browse-function'"
  (if-let* ((url (and (stringp cand) (get-text-property 0 :url cand))))
      (funcall consult-web-alternate-browse-function url)))

(defun consult-web-embark-external-browse-search-link (cand)
  "Open the search url (the search engine page) in the external browser."
  (if-let* ((search-url (and (stringp cand) (get-text-property 0 :search-url cand))))
      (funcall #'browse-url search-url)))

(defun consult-web-embark-show-preview (cand)
  "Get a preview of CAND.

Gets the preview function from `consult-web-sources-alist'."
  (let* ((source (and (stringp cand) (get-text-property 0 :source cand))))
    (funcall (plist-get (cdr (assoc source consult-web-sources-alist)) :on-preview) cand))
  )

#+end_src
*** keymap
#+begin_src emacs-lisp

;;; Define Embark Keymaps

(defvar-keymap consult-web-embark-general-actions-map
  :doc "Keymap for consult-web-embark"
  :parent embark-general-map
  "i t"  #'consult-web-embark-insert-title
  "i u" #'consult-web-embark-insert-url-link
  "w t" #'consult-web-embark-copy-title-as-kill
  "w u" #'consult-web-embark-copy-url-as-kill
  "o o" #'consult-web-embark-external-browse-link
  "o O" #'consult-web-embark-alternate-browse-link
  "o s" #'consult-web-embark-external-browse-search-link
  "o p" #'consult-web-embark-show-preview
  )


(add-to-list 'embark-keymap-alist '(consult-web . consult-web-embark-general-actions-map))

#+end_src
** Scholar
*** actions
#+begin_src emacs-lisp
(defun consult-web-embark-scholar-external-browse-doi (cand)
  "Open the DOI url in external browser"
  (if-let* ((doi (and (stringp cand) (get-text-property 0 :doi cand))))
      (funcall #'browse-url (concat "https://doi.org/" doi))))

(defun consult-web-embark-scholar-copy-authors-as-kill (cand)
  "Copy the authors of the candidate to `kill-ring'."
  (if-let ((authors (and (stringp cand) (get-text-property 0 :authors cand))))
      (kill-new (string-trim (format " %s " authors)))
    ))

(defun consult-web-embark-scholar-insert-authors (cand)
  "Insrt the authors of the candidate at point."
  (if-let ((authors (and (stringp cand) (get-text-property 0 :authors cand))))
      (insert (string-trim (mapconcat #'identity authors ", ")))
    ))
#+end_src
*** keymap
#+begin_src emacs-lisp

(defvar-keymap consult-web-embark-scholar-actions-map
  :doc "Keymap for consult-web-embark"
  :parent consult-web-embark-general-actions-map
  "o d" #'consult-web-embark-scholar-external-browse-doi
  "w a" #'consult-web-embark-scholar-copy-authors-as-kill
  "i a" #'consult-web-embark-scholar-insert-authors
  )

(add-to-list 'embark-keymap-alist '(consult-web-scholar . consult-web-embark-scholar-actions-map))

(add-to-list 'embark-default-action-overrides '(consult-web-scholar . consult-web-embark-default-action))

#+end_src
** Video
*** actions
#+begin_src emacs-lisp

#+end_src
*** keymap
#+begin_src emacs-lisp

(defvar-keymap consult-web-embark-video-actions-map
  :doc "Keymap for consult-web-embark"
  :parent consult-web-embark-general-actions-map
  )

(add-to-list 'embark-keymap-alist '(consult-web-video . consult-web-embark-video-actions-map))

(add-to-list 'embark-default-action-overrides '(consult-web-video . consult-web-embark-default-action))

#+end_src

** Provide and Footer
#+begin_src emacs-lisp
;;; Provide `consul-web-embark' module

(provide 'consult-web-embark)

;;; consult-web-embark.el ends here
#+end_src
* sources
** Multi Sources
*** all sources
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-sources.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-web-sources.el --- Sources for Consulting Web Search Engines -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

(eval-when-compile
  (require 'consult-web)
)
#+end_src
**** define all source modules
#+begin_src emacs-lisp
(setq consult-web-sources--all-modules-list
      (list 'consult-web-bing
            'consult-web-brave-autosuggest
            'consult-web-brave
            'consult-web-buffer
            'consult-web-chatgpt
            'consult-web-doi
            'consult-web-duckduckgo
            'consult-web-elfeed
            'consult-web-google
            'consult-web-google-autosuggest
            'consult-web-gptel
            'consult-web-line-multi
            'consult-web-notes
            'consult-web-pubmed
            'consult-web-scopus
            'consult-web-stackoverflow
            'consult-web-wikipedia
            'consult-web-youtube))
#+end_src
**** add individual or list of sources
#+begin_src emacs-lisp
(defun consult-web-sources--load-module (symbol)
"Loads feature SYMBOL"
(require symbol))

(defun consult-web-sources-load-modules (&optional list)
  "Loads the LIST of symbols.
If list is nil, loads `consult-web-sources-modules-to-load'and if that is nil as well, loads `consult-web-sources--all-modules-list'."
  (mapcar #'consult-web-sources--load-module (or list consult-web-sources-modules-to-load consult-web-sources--all-modules-list)))
#+end_src
**** load the sources
#+begin_src emacs-lisp
(consult-web-sources-load-modules)
#+end_src


**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-sources' module

(provide 'consult-web-sources)
;;; consult-web-sources.el ends here
#+end_src
** Single Source
*** chatGPT
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-chatgpt.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-web-chatgpt.el --- Consulting chatGPT -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-web)
#+end_src

**** format
#+begin_src emacs-lisp
(defun consult-web-dynamic--chatgpt-format-candidate (source query title &optional model face)
  "Returns a formatted string for candidates of `consult-web-chatgpt'.

TABLE is a hashtable from `consult-web--chatgpt-fetch-results'."
  (let* ((source (if (stringp source) (propertize source 'face 'consult-web-source-face)))
         (title-str (consult-web--set-string-width title (floor (* (frame-width) 0.4))))
         (title-str (propertize title-str 'face (or face 'consult-web-ai-source-face)))
         (str (concat title-str "\t"
                      (propertize " " 'display '(space :align-to center))
                      (if model (propertize (format "model: %s" model) 'face 'consult-web-path-face))
                      (if source (concat "\t" source))))
         (match-str (if (stringp query) (consult--split-escaped query) nil))
         )
    (if consult-web-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-web--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-web--highlight-match match-str str t)))))
    str))
#+end_src

**** preview
#+begin_src emacs-lisp
(defun consult-web--chatgpt-response-preview (response &optional query)
  "Returns a buffer with formatted RESPONSE from chatGPT"
  (save-excursion
    (let ((buff (get-buffer-create "*consult-web-chatgpt-response*")))
      (with-current-buffer buff
        (erase-buffer)
        (if query (insert (format "# User:\n\n %s\n\n" query)))
        (if response (insert (format "# chatGPT:\n\n %s\n\n" response)))
        (if (featurep 'mardown-mode)
            (require 'markdown-mode)
          (markdown-mode)
          )
        (point-marker))
      )))


(defun consult-web--chatgpt-preview (cand)
  "Shows a preview buffer with chatGPT response from CAND"
  (when-let ((buff (get-buffer "*consult-web-chatgpt-response*")))
    (kill-buffer buff))

  (if (listp cand) (setq cand (or (car-safe cand) cand)))
  (when-let*  ((query  (get-text-property 0 :query cand))
               (response (or (get-text-property 0 :title cand) cand))
               (marker (consult-web--chatgpt-response-preview response query)))
    (consult--jump marker)
))
#+end_src
**** chatgpt with http-request
#+begin_src emacs-lisp
(defvar consult-web-chatgpt-api-url "https://api.openai.com/v1/chat/completions")

(defcustom consult-web-openai-api-key nil
"Key for OpeAI API

See URL `https://openai.com/product' and URL `https://platform.openai.com/docs/introduction' for details"
:group 'consult-web
:type '(choice (const :tag "API Key" string)
               (function :tag "Custom Function")))


(cl-defun consult-web--chatgpt-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetches chat response for INPUT from chatGPT."
  (pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
               (opts (car-safe opts))
               (model (or (plist-get opts :model) "gpt-3.5-turbo"))
               (headers `(("Content-Type" . "application/json")
                    ("Authorization" . ,(concat "Bearer " (consult-web-expand-variable-function consult-web-openai-api-key))))))
    (consult-web--fetch-url consult-web-chatgpt-api-url
                            consult-web-http-retrieve-backend
      :type "POST"
      :encoding 'utf-8
      :headers headers
      :data  (json-encode `((model . ,model)
                    (messages . [((role . "user")
                                  (content . ,query))])))
      :parser #'consult-web--default-url-parse-buffer
      :callback
      (lambda (attrs)
        (let* ((source "chatGPT")
                    (url nil)
                    (search-url nil)
                    (choices (car-safe (gethash "choices" attrs)))
                    (title (and choices (map-nested-elt choices '("message" "content"))))
                    (model model)
                    (decorated (consult-web-dynamic--chatgpt-format-candidate source query title model))
                    (annotated-results (and decorated (propertize decorated
                                             :source source
                                             :title title
                                             :url url
                                             :search-url search-url
                                             :query query))))
          (when annotated-results
          (funcall callback (list annotated-results)))
          annotated-results)))))

(consult-web-define-source "chatGPT"
                           :narrow-char ?G
                           :type 'async
                           :face 'consult-web-ai-source-face
                           :request #'consult-web--chatgpt-fetch-results
                           :format #'consult-web-dynamic--chatgpt-format-candidate
                           :preview-key consult-web-preview-key
                           :on-preview #'consult-web--chatgpt-preview
                           :on-return #'identity
                           :on-callback #'consult-web--chatgpt-preview
                           :search-history 'consult-web--search-history
                           :selection-history 'consult-web--selection-history
                           :enabled (lambda () (bound-and-true-p consult-web-openai-api-key))
                           :group #'consult-web--group-function
                           :sort t
                           :dynamic 'both
                           :annotate nil
                           )


#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-chatgpt' module

(provide 'consult-web-chatgpt)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-chatgpt)
;;; consult-web-chatgpt.el ends here
#+end_src


*** Bing
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-bing.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-web-bing.el --- Consulting Bing -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:
(require 'consult-web)
#+end_src
**** bing
#+begin_src emacs-lisp
(defvar consult-web-bing-search-api-url "https://api.bing.microsoft.com/v7.0/search")

(defcustom consult-web-bing-search-api-key nil
  "Key for Bing (Microsoft Azure) search API

See URL `https://www.microsoft.com/en-us/bing/apis/bing-web-search-api' and URL `https://learn.microsoft.com/en-us/bing/search-apis/bing-web-search/search-the-web' for details"
  :group 'consult-web
  :type '(choice (const :tag "API Key" string)
                 (function :tag "Custom Function")))

(cl-defun consult-web--bing-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetches search results for INPUT from Bing web search api.

Refer to URL `https://programmablesearchengine.google.com/about/' and `https://developers.google.com/custom-search/' for more info.
"
  (pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and (integerp count) count)
                          (and count (string-to-number (format "%s" count)))
                          consult-web-default-count))
               (page (or (and (integerp page) page)
                         (and page (string-to-number (format "%s" page)))
                         consult-web-default-page))
               (count (max count 1))
               (page (* page count))
               (params `(("q" . ,(replace-regexp-in-string " " "+" query))
                         ("count" . ,(format "%s" count))
                         ("offset" . ,(format "%s" page))))
               (headers `(("Ocp-Apim-Subscription-Key" . ,(consult-web-expand-variable-function consult-web-bing-search-api-key)))))
    (consult-web--fetch-url consult-web-bing-search-api-url consult-web-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :headers headers
                            :parser #'consult-web--default-url-parse-buffer
                            :callback
                            (lambda (attrs)
                              (let* ((raw-results (map-nested-elt attrs '("webPages" "value")))
                                     (search-url (gethash "webSearchUrl" attrs))
                                     (annotated-results
                                      (mapcar (lambda (item)
                                                (let*
                                                    ((source "Bing")
                                                     (url (format "%s" (gethash "url" item)))
                                                     (title (gethash "name" item))
                                                     (snippet (gethash "snippet" item))
                                                     (decorated (funcall consult-web-default-format-candidate :source source :query query :url url :search-url search-url :title title :snippet snippet)))
                                                  (propertize decorated
                                                              :source source
                                                              :title title
                                                              :url url
                                                              :search-url search-url
                                                              :query query
                                                              :snippet snippet)))

                                              raw-results)))
                                (when annotated-results
                                  (funcall callback annotated-results))
                                annotated-results)))))

(consult-web-define-source "Bing"
                           :narrow-char ?m
                           :type 'async
                           :face 'consult-web-engine-source-face
                           :format #'consult-web--bing-format-candidate
                           :request #'consult-web--bing-fetch-results
                           :preview-key consult-web-preview-key
                           :search-history 'consult-web--search-history
                           :selection-history 'consult-web--selection-history
                           :enabled (lambda () (bound-and-true-p consult-web-bing-search-api-key))
                           :group #'consult-web--group-function
                           :sort t
                           :dynamic 'both
                           :annotate nil
                           )
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-bing' module

(provide 'consult-web-bing)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-bing)
;;; consult-web-bing.el ends here
#+end_src


*** Brave
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-brave.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-web-brave.el --- Consulting Brave -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-web)
#+end_src


**** brave
#+begin_src emacs-lisp
(defvar consult-web-brave-search-url "https://search.brave.com/search")

(defvar consult-web-brave-url "https://api.search.brave.com/res/v1/web/search")

(defcustom consult-web-brave-api-key nil
  "Key for Brave API.

See URL `https://brave.com/search/api/' for more info"
  :group 'consult-web
  :type '(choice (const :tag "Brave API Key" string)
                 (function :tag "Custom Function")))


(cl-defun consult-web--brave-fetch-results (input &rest args &key callback &allow-other-keys)
  ""
  (pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and (integerp count) count)
                          (and count (string-to-number (format "%s" count)))
                          consult-web-default-count))
               (page (or (and (integerp page) page)
                         (and page (string-to-number (format "%s" page)))
                         consult-web-default-page))
               (count (min (max count 1) 20))
               (params `(("q" . ,(url-hexify-string query))
                         ("count" . ,(format "%s" count))
                         ("page" . ,(format "%s" page))))
               (headers `(("User-Agent" . "Emacs:consult-web/0.1 (Emacs consult-web package; https://github.com/armindarvish/consult-web)")
                          ("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("X-Subscription-Token" . ,(consult-web-expand-variable-function consult-web-brave-api-key))
                          )))
    (consult-web--fetch-url consult-web-brave-url consult-web-http-retrieve-backend
      :encoding 'utf-8
      :params params
      :headers headers
      :parser #'consult-web--default-url-parse-buffer
      :callback
      (lambda (attrs)
        (when-let* ((raw-results (map-nested-elt attrs '("web" "results")))
                    (annotated-results
                     (mapcar (lambda (item)
                               (let*
                                   ((source "Brave")
                                    (url (gethash "url" item))
                                    (title (gethash "title" item))
                                    (snippet (gethash "description" item))
                                    (search-url (consult-web--make-url-string consult-web-brave-search-url params))
                                    (decorated (funcall consult-web-default-format-candidate :source source :query query :url url :search-url search-url :title title :snippet snippet)))
                                 (propertize decorated
                                             :source source
                                             :title title
                                             :url url
                                             :search-url search-url
                                             :query query
                                             :snippet snippet)))

                             raw-results)))
          (funcall callback annotated-results)
          annotated-results)))))

(consult-web-define-source "Brave"
                           :narrow-char ?b
                           :type 'async
                           :face 'consult-web-engine-source-face
                           :request #'consult-web--brave-fetch-results
                           :preview-key consult-web-preview-key
                           :search-history 'consult-web--search-history
                           :selection-history 'consult-web--selection-history
                           :enabled (lambda () (bound-and-true-p consult-web-brave-api-key))
                           :group #'consult-web--group-function
                           :sort t
                           :dynamic 'both
                           )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-brave' module

(provide 'consult-web-brave)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-brave)
;;; consult-web-brave.el ends here
#+end_src
*** Brave AutoSuggest
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-brave-autosuggest.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-web-brave-autosuggest.el --- Consulting Brave Autosuggest -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-web)
#+end_src
**** brave autosuggest
#+begin_src emacs-lisp
(defvar consult-web-brave-autosuggest-api-url "https://api.search.brave.com/res/v1/suggest/search")

(defcustom consult-web-brave-autosuggest-api-key nil
  "Key for Brave Autosuggest API.

See URL `https://brave.com/search/api/' for more info"
  :group 'consult-web
  :type '(choice (const :tag "Brave Autosuggest API Key" string)
                 (function :tag "Custom Function")))

(cl-defun consult-web--brave-autosuggest-fetch-results (input &rest args &key callback &allow-other-keys)
  ""
  (pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and (integerp count) count)
                          (and count (string-to-number (format "%s" count)))
                          consult-web-default-count))
               (page (or (and (integerp page) page)
                         (and page (string-to-number (format "%s" page)))
                         consult-web-default-page))
               (count (min (max count 1) 20))
               (params  `(("q" . ,query)
                          ("count" . ,(format "%s" count))
                          ("page" . ,(format "%s" page))
                          ("country" . "US")))
               (headers `(("User-Agent" . "Emacs:consult-web/0.1 (Emacs consult-web package; https://github.com/armindarvish/consult-web)")
                          ("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("X-Subscription-Token" . ,(consult-web-expand-variable-function consult-web-brave-autosuggest-api-key))
                          )))
    (consult-web--fetch-url consult-web-brave-autosuggest-api-url consult-web-http-retrieve-backend
                                  :params params
                                  :headers headers
                                  :parser #'consult-web--default-url-parse-buffer
                                  :callback
                                  (lambda (attrs)
                                    (when-let* ((original (make-hash-table :test 'equal))
                                                (_ (puthash "query" (gethash "original" (gethash "query" attrs)) original))
                                                (raw-results  (append (map-nested-elt attrs '("results")) (list original)))
                                                (annotated-results
                                                 (mapcar (lambda (item)
                                                           (let* ((source "Brave AutoSuggest")
                                                                  (word (gethash "query" item))
                                                                  (url (concat "https://search.brave.com/search?q="  (replace-regexp-in-string " " "+" word)))
                                                                  (urlobj (and url (url-generic-parse-url url)))
                                                                  (domain (and (url-p urlobj) (url-domain urlobj)))
                                                                  (domain (and (stringp domain)
                                                                               (propertize domain 'face 'font-lock-variable-name-face)))
                                                                  (path (and (url-p urlobj) (url-filename urlobj)))
                                                                  (path (and (stringp path)
                                                                             (propertize path 'face 'font-lock-warning-face)))
                                                                  (search-url nil)
                                                                  (decorated (propertize word 'face 'consult-web-default-face)))
                                                             (propertize decorated
                                                                         :source source
                                                                         :title word
                                                                         :url url
                                                                         :search-url search-url
                                                                         :query query)))

                                                         raw-results)))
                                      (funcall callback annotated-results)
                                      annotated-results)))))

(consult-web-define-source "Brave AutoSuggest"
                           :narrow-char ?B
                           :type 'async
                           :face 'consult-web-engine-source-face
                           :request #'consult-web--brave-autosuggest-fetch-results
                           :group #'consult-web--group-function
                           :on-preview #'ignore
                           :on-return #'string-trim
                           :on-callback #'string-trim
                           :search-history 'consult-web--search-history
                           :selection-history t
                           :enabled (lambda () (bound-and-true-p consult-web-brave-autosuggest-api-key))
                           :sort t
                           :dynamic t
                           )
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-brave-autosuggest' module

(provide 'consult-web-brave-autosuggest)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-brave-autosuggest)
;;; consult-web-brave-autosuggest.el ends here
#+end_src

*** consult-line-multi
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-line-multi.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-web-line-multi.el --- Search Lines in All Buffers  -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult)
(require 'consult-web)
#+end_src

**** items
#+begin_src emacs-lisp :lexical t
(defun consult-web--line-multi-candidates (input &optional buffers)
  "Wrapper around consult--line-multi-candidates for consult-web."
  (let  ((buffers (or buffers (consult--buffer-query :directory (consult--normalize-directory default-directory) :sort 'alpha-current))))
    (consult--line-multi-candidates buffers input)))
#+end_src
**** fetch-results
#+begin_src emacs-lisp :lexical t

(cl-defun consult-web--line-multi-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetches search results for INPUT from `consult-line-multi'."
(unless (functionp 'consult-web--line-multi-candidates)
  (error "consult-web: consult-web-line-multi not available. Make sure `consult' is loaded properly"))
(pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
               (opts (car-safe opts))
               (items (consult-web--line-multi-candidates query))
               (annotated-results (mapcar (lambda (item)
                                            (let* ((source "Consult Line Multi")
                                                   (marker  (consult--get-location item))
                                                   (title (substring-no-properties item 0 -1))
                                                   (decorated (consult-web--line-multi-format-candidate :source source :query query :marker marker :title title)))
                                           (propertize decorated
                                                       :source source
                                                       :title title
                                                       :url nil
                                                       :marker marker
                                                       :query query
                                                       ))) items)))
    annotated-results))
#+end_src


**** format
#+begin_src emacs-lisp
(cl-defun consult-web--line-multi-format-candidate (&rest args &key source query marker title face &allow-other-keys)
  "Returns a formatted string for candidates of `consult-web-dynamic-line-multi'.

TABLE is a hashtable from `consult-web--line-multi-fetch-results'."
  (let* ((source (if (stringp source) (propertize source 'face 'consult-web-source-face)))
         (marker (car marker))
         (buff (marker-buffer marker))
         (pos (marker-position marker))
         (buff (and buff (propertize (format "%s" buff) 'face 'consult-web-domain-face)))
         (pos (and pos (propertize (format "%s" pos) 'face 'consult-web-path-face)))
         (match-str (if (stringp query) (consult--split-escaped (car (consult--command-split query))) nil))
         (face (or (consult-web--get-source-prop source :face) face 'consult-web-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-web--set-string-width title-str (* 6 frame-width-percent)))
         (str (concat title-str
                      (when buff (concat "\t" buff))
                      (when pos (concat "\s\s" pos ))
                      (when source (concat "\t" source))))
         )
    (if consult-web-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-web--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-web--highlight-match match-str str t)))))
    str))
#+end_src

**** preview
#+begin_src emacs-lisp

(defun consult-web--line-multi-preview (cand)
"Preview function for consult-web-line-multi."
  (let* ((marker (car (get-text-property 0 :marker cand)))
         (query (get-text-property 0 :query cand)))
    (consult--jump marker)
       ))

#+end_src
**** define source
#+begin_src emacs-lisp

(consult-web-define-source "Consult Line Multi"
                           :narrow-char ?L
                           :type 'sync
                           :category 'consult-location
                           :face 'default
                           :request #'consult-web--line-multi-fetch-results
                           :preview-key consult-preview-key
                           :search-history 'consult-web--search-history
                           :selection-history 'consult-web--selection-history
                           :on-preview #'consult-web--line-multi-preview
                           :on-return #'identity
                           :on-callback #'consult-web--line-multi-preview
                           :enabled (lambda () (fboundp 'consult-web--line-multi-candidates))
                           :group #'consult-web--group-function
                           :sort t
                           :dynamic 'both
                           :annotate nil
                           )
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-line-multi' module

(provide 'consult-web-line-multi)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-line-multi)
;;; consult-web-line-multi.el ends here
#+end_src


*** consult-buffer
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-buffer.el
:END:
**** header

#+begin_src emacs-lisp
;;; consult-web-buffer.el --- Consulting Buffers -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-web)
#+end_src

**** preview
#+begin_src emacs-lisp
(defun consult-web--consult-buffer-preview (cand)
  "Preview function for `consult-web--buffer'."
  (if cand
      (let* ((title (get-text-property 0 :title cand)))
        (when-let ((buff (get-buffer title)))
          (consult--buffer-action buff))
        )))
#+end_src
**** consult-buffer
#+begin_src emacs-lisp
(cl-loop for source in consult-buffer-sources
         do (if (symbolp source) (consult-web--make-source-from-consult-source source
                                              :type 'sync
                                              :on-preview #'consult-web--consult-buffer-preview
                                              :on-return #'identity
                                              :on-callback #'consult--buffer-action
                                              :search-history 'consult-web--search-history
                                              :selection-history 'consult-web--selection-history
                                              :dynamic 'both
                                              :preview-key 'consult-web-preview-key
                                              :group #'consult-web--group-function
                                              )))
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-buffer' module

(provide 'consult-web-buffer)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-buffer)
;;; consult-web-buffer.el ends here
#+end_src


*** consult-notes
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-notes.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-web-notes.el --- Consulting Notes -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-web)
(require 'consult-notes)
#+end_src

**** preview
#+begin_src emacs-lisp
(defun consult-web--org-roam-note-preview (cand)
  "Preview function for org-roam files."
  (if cand
      (let* ((title (get-text-property 0 :title cand))
             (node (org-roam-node-from-title-or-alias title)))
        (if (org-roam-node-p node)
            (consult--file-action (org-roam-node-file node))
          ))))

(defun consult-web--org-headings-preview (cand)
  "Preview function for org headings."
  (if cand
      (let* ((title (get-text-property 0 :title cand))
             (marker (get-text-property 0 'consult--candidate title)))
        (if marker
            (consult--jump marker)))))
#+end_src

**** callback
#+begin_src emacs-lisp
(defun consult-web--org-roam-note-callback (cand &rest args)
  "Callback function for org-roam files."
  (let* ((title (get-text-property 0 :title cand))
         (node (org-roam-node-from-title-or-alias title)))
    (org-roam-node-open node)))

(defun consult-web--org-headings-callback (cand &rest args)
  "Callback function for org headings."
  (if cand
      (let* ((title (get-text-property 0 :title cand))
             (marker (get-text-property 0 'consult--candidate title)))
        (if marker
           (let* ((buff (marker-buffer marker))
                 (pos (marker-position marker)))
             (if buff (with-current-buffer buff
               (if pos (goto-char pos))
               (funcall consult--buffer-display buff)
               (recenter nil t)
               )))
             ))))
#+end_src

**** consult-notes-org-headings
#+begin_src emacs-lisp
(when consult-notes-org-headings-mode
  (consult-web--make-source-from-consult-source 'consult-notes-org-headings--source
                                                :category 'file
                                                :type 'sync
                                                :face 'consult-web-notes-source-face
                                                :search-history 'consult-web--search-history
                                                :selection-history 'consult-web--selection-history
                                                :on-preview #'consult-web--org-headings-preview
                                                :on-return #'identity
                                                :on-callback #'consult-web--org-headings-callback
                                                :search-history 'consult-web--search-history
                                                :selection-history 'consult-web--selection-history
                                                :preview-key 'consult-preview-key
                                                :group #'consult-web--group-function
                                                :dynamic 'both
                                                ))
#+end_src

**** consult-notes-org-roam
#+begin_src emacs-lisp
(when consult-notes-org-roam-mode
  (cl-loop for source in '(consult-notes-org-roam--refs consult-notes-org-roam--nodes)
           do (consult-web--make-source-from-consult-source source
                                                            :category 'file
                                                            :type 'sync
                                                            :face 'consult-web-notes-source-face
                                                            :search-history 'consult-web--search-history
                                                            :selection-history 'consult-web--selection-history
                                                            :on-preview #'consult-web--org-roam-note-preview
                                                            :on-return #'identity
                                                            :on-callback #'consult-web--org-roam-note-callback

                                                            :preview-key 'consult-preview-key
                                                            :dynamic 'both
                                                            :group #'consult-web--group-function
                                                            :annotate nil
                                                            )))
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-notes' module

(provide 'consult-web-notes)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-notes)
;;; consult-web-notes.el ends here
#+end_src



*** Doi.org
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-doi.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-web-doi.el --- Consulting DOI.org -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-web)
#+end_src
**** doi
#+begin_src emacs-lisp
(defvar consult-web-doiorg-api-url "https://doi.org/api/handles/")

(defvar consult-web-doiorg-search-url "https://doi.org/")

(defun consult-web--doi-to-url (doi)
  "Converts DOI value to target url"
  (let ((out))
    (let* ((doi (if doi (format "%s" doi)))
           (url (concat consult-web-doiorg-api-url doi)))
       (consult-web--fetch-url url consult-web-http-retrieve-backend
                               :sync t
                               :encoding 'utf-8
                               :parser #'consult-web--default-url-parse-buffer
                               :callback
                               (lambda (attrs)
                                 (let* ((raw-results (map-nested-elt attrs '("values")))
                                        (result (car-safe (remove nil (mapcar (lambda (item)
                                                                                     (if-let* ((type (gethash "type" item))                                                                                                        (link (if (equal type "URL") (map-nested-elt item '("data" "value")))))
                                                                                         link))
                                                                                   raw-results)))))
                                  result))))))


(cl-defun consult-web--doiorg-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch target url of DOI.
"
  (pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
               (opts (car-safe opts))
               (source "doiorg")
               (url (consult-web--doi-to-url query))
               (title (format "%s" query))
               (search-url (concat consult-web-doiorg-search-url query))
               (decorated (funcall consult-web-default-format-candidate :source source :query query :url url :search-url search-url :title title))
               (annotated-results (propertize decorated
                                              :source source
                                              :title title
                                              :url url
                                              :search-url search-url
                                              :query query)))
    (list annotated-results)
          ))


(defvar consult-web--doi-search-history (list)
  "History variables for search terms when using
`consult-web-doi' commands.")

(defvar consult-web--doi-selection-history (list)
  "History variables for selected items when using
`consult-web-doi' commands.")


(consult-web-define-source "doiorg"
                           :narrow-char ?d
                           :type 'sync
                           :face 'link
                           :request #'consult-web--doiorg-fetch-results
                           :preview-key consult-web-preview-key
                           :search-history 'consult-web--doi-search-history
                           :selection-history 'consult-web--doi-selection-history
                           :enabled (lambda () (bound-and-true-p consult-web-doiorg-search-url))
                           :group #'consult-web--group-function
                           :sort t
                           :dynamic 'both
                           )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-doi' module

(provide 'consult-web-doi)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-doi)
;;; consult-web-doi.el ends here
#+end_src


*** DuckDuckGo
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-duckduckgo.el
:END:
**** header

#+begin_src emacs-lisp
;;; consult-web-duckduckgo.el --- Consulting DuckDuckGo -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-web)
#+end_src

**** duckduckgo limited API
#+begin_src emacs-lisp
(defvar consult-web-duckduckgo-api-url "http://api.duckduckgo.com/")

(defvar consult-web-duckduckgo-search-url "https://duckduckgo.com/")

(cl-defun consult-web--duckduckgoapi-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results got INPUT from DuckDuckGo limited API.

See URL `https://duckduckgo.com/duckduckgo-help-pages/settings/params/'
for some limited documentation"
  (pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (extra-args (seq-difference (append opts args) '(:count count :page page)))
               (count (or (and (integerp count) count)
                          (and count (string-to-number (format "%s" count)))
                          consult-web-default-count))
               (page (or (and (integerp page) page)
                         (and page (string-to-number (format "%s" page)))
                         consult-web-default-page))
               (count (min count 10))
               (page (+ (* page count) 1))
               (params `(("q" . ,input)
                   ("format" . "json")))
               (headers `(("Accept" . "application/json"))))
    (consult-web--fetch-url consult-web-duckduckgo-api-url consult-web-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :headers headers
                            :parser #'consult-web--default-url-parse-buffer
                            :callback
                            (lambda (attrs)
                              (let* ((raw-results (gethash "RelatedTopics" attrs))
                                     (annotated-results
                                           (mapcar (lambda (item)
                                                     (let*
                                                         ((source "DuckDuckGo API")
                                                          (url (gethash "FirstURL" item))
                                                          (title (gethash "Result" item))
                                                          (title (if (string-match "<a href=.*>\\(?1:.*\\)</a>.*" title) (match-string 1 title) ""))
                                                          (snippet (format "%s" (gethash "Text" item)))

                                                          (search-url (consult-web--make-url-string consult-web-duckduckgo-search-url params '("format")))

                                                          (decorated (funcall consult-web-default-format-candidate :source source :query query :url url :search-url search-url :title title :snippet snippet)))
                                                       (propertize decorated
                                                                   :source source
                                                                   :title title
                                                                   :url url
                                                                   :search-url search-url
                                                                   :query query
                                                                   )))

                                                   raw-results)))
                                (when annotated-results
                                  (funcall callback annotated-results))
                                annotated-results)))))


(consult-web-define-source "DuckDuckGo API"
                           :narrow-char ?d
                           :type 'async
                           :face 'consult-web-engine-source-face
                           :request #'consult-web--duckduckgoapi-fetch-results
                           :preview-key consult-web-preview-key
                           :search-history 'consult-web--search-history
                           :selection-history 'consult-web--selection-history
                           :enabled (lambda () (bound-and-true-p consult-web-duckduckgo-search-url))
                           :group #'consult-web--group-function
                           :sort t
                           :dynamic t
                           :annotate nil
                           )
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-duckduckgo' module

(provide 'consult-web-duckduckgo)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-duckduckgo)
;;; consult-web-duckduckgo.el ends here
#+end_src


*** elfeed
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-elfeed.el
:END:
**** header

#+begin_src emacs-lisp
;;; consult-web-elfeed.el --- Consulting Elfeed -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web/blob/main/consult-web-sources
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'elfeed)
(require 'consult-web)
#+end_src

**** custom variables
#+begin_src emacs-lisp
;;; Customization Variables
(defcustom consult-web-elfeed-search-buffer-name "*consult-web-elfeed-search*"
  "Name for consult-web-elfeed-search buffer."
  :type 'string)

(defcustom consult-web-elfeed-default-filter nil
  "Default Filter for consult-web-elfeed-search."
  :type 'string)
#+end_src
**** format
#+begin_src emacs-lisp
(defun consult-web--elfeed-format-candidate (entries query)
  (let ((annotated-entries))
    (dolist (entry entries annotated-entries)
      (let* ((url (elfeed-entry-link entry))
             (urlobj (if url (url-generic-parse-url url)))
             (domain (if (url-p urlobj) (url-domain urlobj)))
             (domain (if (stringp domain) (propertize domain 'face 'consult-web-domain-face)))
             (path (if (url-p urlobj) (url-filename urlobj)))
             (path (if (stringp path) (propertize path 'face 'consult-web-path-face)))
             (title (or (elfeed-entry-title entry) ""))
             (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
             (feed (elfeed-entry-feed entry))
             (feed-title (when feed (elfeed-feed-title feed)))
             (date (format-time-string "%Y-%m-%d %H:%M" (elfeed-entry-date entry)))
             (id (elfeed-entry-id entry))
             (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
             (tags-str (mapconcat
                        (lambda (s) (propertize s 'face 'elfeed-search-tag-face))
                        tags ","))
             (title-width (- (floor (* (frame-width) 0.7)) elfeed-search-trailing-width))
             (title-column (elfeed-format-column
                            title (elfeed-clamp
                                   elfeed-search-title-min-width
                                   title-width
                                   elfeed-search-title-max-width)
                            :left))
             (match-str (if (stringp query) (consult--split-escaped (car (consult--command-split query))) nil))
             (str (concat (propertize title-column 'face title-faces 'kbd-help title) " "
                          (propertize date 'face 'elfeed-search-date-face)
                          (when feed-title
                            (concat " " (propertize feed-title 'face 'elfeed-search-feed-face)))
                          (when tags (concat " " "(" tags-str ")"))
                          (when domain (concat "\t" domain (when path path)))
                          (concat "\t" (propertize "elfeed" 'face 'consult-web-source-face))
                          )))
        (if consult-web-highlight-matches
            (cond
             ((listp match-str)
              (mapcar (lambda (match) (setq str (consult-web--highlight-match match str t))) match-str))
             ((stringp match-str)
              (setq str (consult-web--highlight-match match-str str t)))))
        (push (propertize str
                          :source "elfeed"
                          :title title
                          :url url
                          :search-url nil
                          :query query
                          :entry entry
                          :tags tags
                          :date date
                          :id id
                          :feed feed
                          )
              annotated-entries)))))
#+end_src
**** main
#+begin_src emacs-lisp :results verbatim drawer
(defun consult-web--elfeed-search-buffer ()
  "Get or create buffer for `consult-web-elfeed'"
  (get-buffer-create (or consult-web-elfeed-search-buffer-name "*consult-web-elfeed-search*")))

(cl-defun consult-web--elfeed-fetch-results (input &rest args &key callback &allow-other-keys)
  "Return entries matching INPUT in elfeed database.
uses INPUT as filter ro find entries in elfeed databse.
if FILTER is non-nil, it is used as additional filter parameters.
"
(cl-letf* (((symbol-function #'elfeed-search-buffer) #'consult-web--elfeed-search-buffer))
  (pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
               (opts (car-safe opts))
               (maxcount (plist-get opts :count))
               (filter (and (plist-member opts :filter) (plist-get opts :filter)))
               (maxcount (or (and (integerp maxcount) maxcount)
                             (and maxcount (string-to-number (format "%s" maxcount)))
                             consult-web-default-count))
               (elfeed-search-filter (concat (if maxcount (format "#%d " maxcount))
                                             (if filter (format "%s" filter)
                                               consult-web-elfeed-default-filter)
                                             (if query (format "%s" query))
                                             ))
               (filter (elfeed-search-parse-filter elfeed-search-filter))
               (head (list nil))
               (tail head)
               (count 0)
               (lexical-binding t)
               (search-func (byte-compile (elfeed-search-compile-filter filter))))
    (with-elfeed-db-visit (entry feed)
      (when (funcall search-func entry feed count)
        (setf (cdr tail) (list entry)
              tail (cdr tail)
              count (1+ count))))
    (when-let ((entries (cdr head)))
      (consult-web--elfeed-format-candidate entries query)))
      ))


(defun consult-web--elfeed-preview (cand)
  "Shows a preview buffer of CAND for `consult-web-elfeed'.
Uses `elfeed-show-entry'."
  (if (listp cand) (setq cand (or (car-safe cand) cand)))
  (let* ((entry (get-text-property 0 :entry cand))
         (buff (get-buffer-create (elfeed-show--buffer-name entry))))
    (with-current-buffer buff
      (elfeed-show-mode)
      (setq elfeed-show-entry entry)
      (elfeed-show-refresh))
    (funcall (consult--buffer-preview) 'preview
             buff
             )))


(consult-web-define-source "elfeed"
                           :narrow-char ?e
                           :type 'sync
                           :face 'elfeed-search-unread-title-face
                           :request #'consult-web--elfeed-fetch-results
                           :on-preview #'consult-web--elfeed-preview
                           :on-return #'identity
                           :on-callback #'consult-web--elfeed-preview
                           :preview-key consult-web-preview-key
                           :search-history 'consult-web--search-history
                           :selection-history 'consult-web--selection-history
                           :enabled (lambda () (boundp 'elfeed-db))
                           :group #'consult-web--group-function
                           :sort t
                           :dynamic 'both
                           :annotate nil
                           )

#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-elfeed' module

(provide 'consult-web-elfeed)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-elfeed)
;;; consult-web-elfeed.el ends here
#+end_src

*** Google
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-google.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-web-google.el --- Consulting Google -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-web)
#+end_src
**** custom search api

#+begin_src emacs-lisp
(defvar consult-web-google-search-url "https://www.google.com/search")

(defvar consult-web-google-customsearch-api-url "https://www.googleapis.com/customsearch/v1")

(defcustom consult-web-google-customsearch-key nil
  "Key for Google custom search API

See URL `https://developers.google.com/custom-search/' and URL `https://developers.google.com/custom-search/v1/introduction' for details"
  :group 'consult-web
  :type '(choice (const :tag "API Key" string)
                 (function :tag "Custom Function")))

(defcustom consult-web-google-customsearch-cx nil
  "CX for Google custom search API

See URL `https://developers.google.com/custom-search/' and URL `https://developers.google.com/custom-search/v1/introduction' for details"
  :group 'consult-web
  :type '(choice (const :tag "CX String" string)
                 (function :tag "Custom Function")))


(cl-defun consult-web--google-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetches search results for INPUT from “Google custom search” service.

Refer to URL `https://programmablesearchengine.google.com/about/' and `https://developers.google.com/custom-search/' for more info.
"
  (pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (filter (plist-get opts :filter))
               (count (or (and (integerp count) count)
                          (and count (string-to-number (format "%s" count)))
                          consult-web-default-count))
               (page (or (and (integerp page) page)
                         (and page (string-to-number (format "%s" page)))
                         consult-web-default-page))
               (filter (or (and (integerp filter) filter)
                           (and filter (string-to-number (format "%s" filter)))
                           1))
               (filter (if (member filter '(0 1)) filter 1))
               (count (min count 10))
               (page (+ (* page count) 1))
               (page (min page (- 100 count)))
               (params `(("q" . ,(replace-regexp-in-string " " "+" query))
                         ("key" . ,(consult-web-expand-variable-function consult-web-google-customsearch-key))
                         ("cx" . ,(consult-web-expand-variable-function consult-web-google-customsearch-cx))
                         ("gl" . "en")
                         ("filter" . ,(format "%s" filter))
                         ("num" . ,(format "%s" count))
                         ("start" . ,(format "%s" page))))
               (headers '(("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("User-Agent" . "consult-web (gzip)"))))
    (consult-web--fetch-url consult-web-google-customsearch-api-url consult-web-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :headers headers
                            :parser #'consult-web--default-url-parse-buffer
                            :callback
                            (lambda (attrs)
                              (let* ((raw-results (gethash "items" attrs))
                                     (annotated-results
                                           (mapcar (lambda (item)
                                                     (let*
                                                         ((source "Google")
                                                          (url (format "%s" (gethash "link" item)))
                                                          (title (format "%s" (gethash "title" item)))
                                                          (snippet (string-trim (format "%s" (gethash "snippet" item))))
                                                          (search-url (consult-web--make-url-string consult-web-google-search-url params '("key" "cx" "gl")))

                                                          (decorated (funcall consult-web-default-format-candidate :source source :query query :url url :search-url search-url :title title :snippet snippet)))
                                                       (propertize decorated
                                                                   :source source
                                                                   :title title
                                                                   :url url
                                                                   :search-url search-url
                                                                   :query query
                                                                   :snippet snippet)))

                                                   raw-results)))
                                (when annotated-results
                                  (funcall callback annotated-results))
                                annotated-results)))))


(consult-web-define-source "Google"
                           :narrow-char ?g
                           :type 'async
                           :face 'consult-web-engine-source-face
                           :request #'consult-web--google-fetch-results
                           :preview-key consult-web-preview-key
                           :search-history 'consult-web--search-history
                           :selection-history 'consult-web--selection-history
                           :enabled (lambda () (bound-and-true-p consult-web-google-customsearch-key))
                           :group #'consult-web--group-function
                           :sort t
                           :dynamic 'both
                           :annotate nil
                           )
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-google' module

(provide 'consult-web-google)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-google)
;;; consult-web-google.el ends here
#+end_src


*** Google Autosuggest
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-google-autosuggest.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-web-google-autosuggest.el --- Consulting Google Autosuggest -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-web)
#+end_src

**** google autosuggest
#+begin_src emacs-lisp
(defvar consult-web-google-autosuggest-api-url "http://suggestqueries.google.com/complete/search")

(cl-defun consult-web--google-autosuggest-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results for INPUT from Google Autosuggest.

Uses `consult-web-google-autosuggest-api-url' as autosuggest api url."
  (pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and (integerp count) count)
                          (and count (string-to-number (format "%s" count)))
                          consult-web-default-count))
               (page (or (and (integerp page) page)
                         (and page (string-to-number (format "%s" page)))
                         consult-web-default-count))
               (params `(("q" . ,query)
                         ("client" . "chrome")))
               (headers `(("Accept" . "application/json"))))
    (consult-web--fetch-url consult-web-google-autosuggest-api-url consult-web-http-retrieve-backend
                            :params params
                            :headers headers
                            :parser #'consult-web--default-url-parse-buffer
                            :callback
                            (lambda (attrs)
                              (when-let* ((raw-results (append (list (car-safe attrs)) (car-safe (cdr-safe attrs))))
                                          (annotated-results
                                           (mapcar (lambda (item)
                                                     (let* ((source "Google AutoSuggest")
                                                            (word item)
                                                            (url                                  (concat "https://www.google.com/search?q="  (replace-regexp-in-string " " "+" word)))
                                                            (urlobj (and url (url-generic-parse-url url)))
                                                            (domain (and (url-p urlobj) (url-domain urlobj)))
                                                            (domain (and (stringp domain)
                                                                         (propertize domain 'face 'font-lock-variable-name-face)))
                                                            (path (and (url-p urlobj) (url-filename urlobj)))
                                                            (path (and (stringp path)
                                                                       (propertize path 'face 'font-lock-warning-face)))
                                                            (search-url nil)
                                                            (decorated (propertize word 'face 'consult-web-default-face)))
                                                       (propertize decorated
                                                                   :source source
                                                                   :title word
                                                                   :url url
                                                                   :search-url search-url
                                                                   :query query)))

                                                   raw-results)))
                                (funcall callback annotated-results)
                                annotated-results)))))

(consult-web-define-source "Google AutoSuggest"
                           :narrow-char ?G
                           :type 'async
                           :face 'consult-web-engine-source-face
                           :request #'consult-web--google-autosuggest-fetch-results
                           :on-preview #'ignore
                           :on-return #'identity
                           :on-callback #'string-trim
                           :search-history 'consult-web--search-history
                           :selection-history t
                           :group #'consult-web--group-function
                           :enabled (lambda () (boundp consult-web-google-autosuggest-api-url))
                           :sort t
                           :dynamic t
                           )
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-google-autosuggest' module

(provide 'consult-web-google-autosuggest)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-google-autosuggest)
;;; consult-web-google-autosuggest.el ends here
#+end_src


*** gptel
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-gptel.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-web-gptel.el --- Consulting gptel -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'gptel)
(require 'consult-web)
#+end_src
**** custom variables
#+begin_src emacs-lisp
;;; Customization Variables
(defcustom consult-web-gptel-buffer-name  "*consult-web-gptel*"
  "Name for consult-web-gptel buffer."
  :type '(choice (:tag "A string for buffer name" string)
                 (:tag "A custom function taking prompt (and other args) as input and returning buffer name string" function)))

#+end_src

**** gptel buffer

***** format
#+begin_src emacs-lisp
(cl-defun consult-web--gptel-format-candidate (&rest args &key source query model backend stream face &allow-other-keys)
  "Returns a formatted string for gptel's candidates

SOURCE is the name string of the source for candidate

QUERY is the query string used for searching

URL is a string pointing to url of the candidate

SEARCH-URL is a string pointing to the url for
the search results of QUERY on the SOURCE website

TITLE is the title of the candidate

SNIPPET is a string containing a snippet/description of candidate
"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (and (stringp source) (propertize source 'face 'consult-web-source-face)))
         (title (format "ask gptel: %s" (if query (string-trim-right query) "")))
         (backend (and (stringp backend) (propertize backend 'face 'consult-web-domain-face)))
         (model (and (stringp model) (propertize model 'face 'consult-web-path-face)))
         (stream (and stream (propertize "~stream~" 'face 'consult-web-snippet-face)))
         (face (or (consult-web--get-source-prop source :face) face 'consult-web-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-web--set-string-width title-str (* 5 frame-width-percent)))
         (str (concat title-str
                      (when backend (concat "\t" backend))
                      (when model (concat ":" model))
                      (when stream (concat "\s" stream "\s"))
                      )))
    (if consult-web-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-web--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-web--highlight-match match-str str t)))))
    str))
#+end_src

***** gptel buffer name
#+begin_src emacs-lisp
(defun consult-web--gptel-buffer-name (&optional query &rest args)
  "Returns a string for `consult-web-gptel' buffer name"
  (cond
   ((functionp consult-web-gptel-buffer-name)
    (funcall consult-web-gptel-buffer-name query args))
   ((stringp consult-web-gptel-buffer-name)
    consult-web-gptel-buffer-name)
   (t
    "*consult-web-gptel*")))
#+end_src
***** preview
#+begin_src emacs-lisp

(cl-defun consult-web--gptel-response-preview (query &rest args &key backend model stream &allow-other-keys)
  "Returns a `gptel' buffer.

QUERY is sent to BACKEND using MODEL.
If STREAM is non-nil, the response is streamed."
  (save-excursion
    (with-current-buffer (gptel (consult-web--gptel-buffer-name query args) nil nil nil)
      (let* ((query-sent)
             (backend (and backend (car (seq-filter (lambda (item) (when (string-match (format "%s" backend) item) item)) (mapcar #'car gptel--known-backends)))))
             (backend (or backend (gptel-backend-name gptel-backend)))
             (backend (cdr (assoc (format "%s" backend) gptel--known-backends)))
             (model (or (and model (format "%s" model))
                        (and backend (car (cl-struct-slot-value (type-of backend) 'models backend)))
                        gptel-model))
             (stream (if stream t nil))
             )
        (setq-local gptel-backend backend)
        (setq-local gptel-model model)
        (setq-local gptel-stream stream)
        (erase-buffer)
        (insert (gptel-prompt-prefix-string))
        (insert (format "%s" query))
        (unless query-sent
          (erase-buffer)
          (insert (gptel-prompt-prefix-string) query)
          (setq query-sent t)
          (gptel-send)))
      (current-buffer))))



(defun consult-web--gptelbuffer-preview (cand)
  "Shows a preview buffer of CAND for `consult-web-gptel'.

The preview buffer is from `consult-web--gptel-response-preview'."
  (if (listp cand) (setq cand (or (car-safe cand) cand)))
  (let*  ((query (get-text-property 0 :query cand))
          (backend (get-text-property 0 :backend cand))
          (model (get-text-property 0 :model cand))
          (stream (get-text-property 0 :stream cand))
          (buff (consult-web--gptel-response-preview query :model model :backend backend :stream stream)))
    (if buff
        (funcall (consult--buffer-preview) 'preview
                 buff
                 ))))
#+end_src
***** main
#+begin_src emacs-lisp
(cl-defun consult-web--gptel-fetch-results (input &rest args &key callback &allow-other-keys)
  "Makes cnaidate with INPUT as placeholder for `consult-web-gptel'.

This makes a placeholder string “ask gptel: %s” %s=INPUT with
metadata MODEL and BACKEND as text properties, so it can be send to
`gptel'."
  (unless (featurep 'gptel)
    (error "consult-web: gptel is not available. Make sure to install and load `gptel'."))
  (pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
               (opts (car-safe opts))
               (backend (and (plist-member opts :backend) (format "%s" (plist-get opts :backend))))
               (backend (and backend (car (seq-filter (lambda (item) (when (string-match (format "%s" backend) item) item)) (mapcar #'car gptel--known-backends)))))
               (backend (or backend (gptel-backend-name gptel-backend)))
               (backend-struct  (cdr (assoc (format "%s" backend) gptel--known-backends)))
               (model (and (plist-member opts :model) (format "%s" (plist-get opts :model))))
               (model (or (and model backend-struct (member model (cl-struct-slot-value (type-of backend-struct) 'models backend-struct)) model)
                          (and backend-struct (car (cl-struct-slot-value (type-of backend-struct) 'models backend-struct)))))
               (stream (or (and (plist-member opts :stream) (plist-get opts :stream)) gptel-stream))
               (placeholder (consult-web--gptel-format-candidate :source source :query query :model model :backend backend :stream stream))
               (annotated-results (propertize placeholder
                                              :source "gptel"
                                              :title query
                                              :url nil
                                              :query query
                                              :model model
                                              :stream stream
                                              :backend backend)))
    (list annotated-results)
    ))



(consult-web-define-source "gptel"
                           :narrow-char ?G
                           :type 'sync
                           :face 'consult-web-ai-source-face
                           :format #'consult-web-dynamic--gptel-format-candidate
                           :request #'consult-web--gptel-fetch-results
                           :on-preview #'consult-web--gptelbuffer-preview
                           :on-return #'identity
                           :on-callback #'consult-web--gptelbuffer-preview
                           :preview-key consult-web-preview-key
                           :search-history 'consult-web--search-history
                           :selection-history 'consult-web--selection-history
                           :enabled (lambda () (fboundp 'gptel))
                           :group #'consult-web--group-function
                           :sort t
                           :dynamic 'both
                           :annotate nil
                           )

#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-gptel' module

(provide 'consult-web-gptel)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-gptel)
;;; consult-web-gptel.el ends here
#+end_src


*** PubMed
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-pubmed.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-web-pubmed.el --- Consulting PubMed -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-web)
#+end_src

**** entrez utils api
***** key
#+begin_src emacs-lisp
(defcustom consult-web-pubmed-api-key nil
  "Key for Pubmed Entrez API.

See URL `https://www.ncbi.nlm.nih.gov/books/NBK25501/' for more info"
  :group 'consult-web
  :type '(choice (const :tag "API Key" string)
                 (function :tag "Custom Function")))
#+end_src
***** esearch
#+begin_src emacs-lisp
(defvar consult-web-pubmed-search-url "https://pubmed.ncbi.nlm.nih.gov/")

(defvar  consult-web-pubmed-esearch-api-url "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi")


(cl-defun consult-web--pubmed-esearch-fetch-results (input &rest args &key db &allow-other-keys)
  "Fetches “esearch” results for INPUT from PubMed Entrez Utilities service.

COUNT is passed as retmax in query parameters.
(* PAGE COUNT) is passed as retstart in query paramters.
DB is passed as db in query parameters. (This is the databes to search.)

Refer to URL `https://www.ncbi.nlm.nih.gov/books/NBK25501/'
for more info."

  (pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and (integerp count) count)
                          (and count (string-to-number (format "%s" count)))
                          consult-web-default-count))
               (page (or (and (integerp page) page)
                         (and page (string-to-number (format "%s" page)))
                         consult-web-default-page))
               (count (min count 20))
               (page (* page count))
               (db (if db (format "%s" db) "pubmed"))
               (params `(("db" . ,db)
                         ("term" . ,(replace-regexp-in-string " " "+" query))
                         ("usehistory" . "y")
                         ("retmax" . ,(format "%s" count))
                         ("retstart" . ,(format "%s" page))
                         ("retmode" . "json")
                         ))
               (headers `(("tool" . "consult-web")
                          ("email" . "contact@armindarvish.com")
                          ("api_key" . ,(consult-web-expand-variable-function consult-web-pubmed-api-key)))))
    (consult-web--fetch-url
     consult-web-pubmed-esearch-api-url consult-web-http-retrieve-backend
     :sync t
     :params params
     :headers headers
     :parser #'consult-web--default-url-parse-buffer
     :callback
     (lambda (attrs)
       (let* ((results (gethash "esearchresult" attrs))
              (webenv (gethash "webenv" results))
              (qk (gethash "querykey" results))
              (idlist (gethash "idlist" results)))
         `(:webenv ,webenv :qk ,qk :idlist ,idlist)
         )))
    ))


#+end_src
***** esummary
#+begin_src emacs-lisp
(defvar consult-web-pubmed-esummary-api-url "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi")

(cl-defun consult-web--pubmed-esummary-fetch-results (input &rest args &key callback webenv qk db &allow-other-keys)
  "Fetches “esearch” results for INPUT from PubMed Entrez Utilities service.

COUNT is passed as retmax in query parameters.
(* PAGE COUNT) is passed as retstart in query paramters.
DB is passed as db in query parameters. (This is the databes to search.)

Refer to URL `https://www.ncbi.nlm.nih.gov/books/NBK25501/'
for more info."

  (pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and (integerp count) count)
                          (and count (string-to-number (format "%s" count)))
                          consult-web-default-count))
               (page (or (and (integerp page) page)
                         (and page (string-to-number (format "%s" page)))
                         consult-web-default-page))
               (page (* page count))
               (webenv (if webenv (format "%s" webenv)))
               (qk (if qk (format "%s" qk)))
               (retmax (min count 500))
               (retstart (max 0 page))
               (db (if db (format "%s" db) "pubmed"))
               (params `(("db" . ,db)
                         ("query_key" . ,qk)
                         ("WebEnv" . ,webenv)
                         ("retmax" . ,(format "%s" retmax))
                         ("retstart" . ,(format "%s" retstart))
                         ("retmode" . "json")
                         ))
               (headers `(("tool" . "consult-web")
                          ("email" . "contact@armindarvish.com")
                          ("api_key" . ,(consult-web-expand-variable-function consult-web-pubmed-api-key)))))
    (consult-web--fetch-url consult-web-pubmed-esummary-api-url consult-web-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :headers headers
                            :parser #'consult-web--default-url-parse-buffer
                            :callback
                            (lambda (attrs)
                              (let* ((results (gethash "result" attrs))
                                     (uids (gethash "uids" results))
                                     (annotated-results
                                           (mapcar (lambda (uid)
                                                     (let*
                                                         ((source "PubMed")
                                                          (url (url-unhex-string (concat consult-web-pubmed-search-url (format "%s" uid))))
                                                          (search-url (consult-web--make-url-string consult-web-pubmed-search-url `(("term" . ,(replace-regexp-in-string " " "+" query)))))
                                                          (data (gethash uid results))
                                                          (title (gethash "title" data))
                                                          (pubdate (date-to-time (gethash "pubdate" data)))
                                                          (date (format-time-string "%Y-%m-%d" pubdate))
                                                          (journal (gethash "fulljournalname" data))
                                                          (authors (mapcar (lambda (item) (gethash "name" item)) (gethash "authors" data)))
                                                          (ids (gethash "articleids" data))
                                                          (doi (car (remove nil (mapcar (lambda (item) (if (equal (gethash "idtype" item) "doi") (gethash "value" item))) ids))))

                                                          (decorated (consult-web-dynamic--pubmed-format-candidate :source source :query query :url url :search-url search-url :title title :authors authors :date date :journal journal :doi doi)))
                                                       (propertize decorated
                                                                   :source source
                                                                   :url url
                                                                   :title title
                                                                   :search-url search-url
                                                                   :query query
                                                                   :journal journal
                                                                   :authors authors
                                                                   :date date
                                                                   :doi doi)))
                                                   uids)))
                                (when annotated-results
                                  (funcall callback annotated-results)
                                    )
                                annotated-results)))))

#+end_src
***** format
#+begin_src emacs-lisp
(cl-defun consult-web-dynamic--pubmed-format-candidate (&rest args &key source query url search-url title authors date journal doi face &allow-other-keys)
  "Returns a formatted string for candidates of `consult-web-pubmed'.

TABLE is a hashtable from `consult-web--pubmed-fetch-results'."
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (if (stringp source) (propertize source 'face 'consult-web-source-face) nil))
         (date (if (stringp date) (propertize date 'face 'consult-web-date-face) nil))
         (journal (if (stringp journal) (propertize journal 'face 'consult-web-domain-face) nil))
         (authors (cond
                   ((and authors (listp authors))
                    (concat (first authors) ",..., " (car (last authors))))
                   ((stringp authors)
                    authors)
                   (t nil)))
         (authors (if (and authors (stringp authors)) (propertize authors 'face 'consult-web-source-face)))
         (doi (if (stringp doi) (propertize doi 'face 'link)))
         (match-str (if (stringp query) (consult--split-escaped query) nil))
         (face (or (consult-web--get-source-prop source :face) face 'consult-web-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-web--set-string-width title-str (* 5 frame-width-percent)))
         (str (concat title-str
                      (if journal (format "\t%s" journal))
                      (if date (format "\s\s%s" date))
                      (if authors (format "\s\s%s" authors))
                      (if source (concat "\t" source))))
         )
    (if consult-web-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-web--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-web--highlight-match match-str str t)))))
    str))
#+end_src
***** main
#+begin_src emacs-lisp
(cl-defun consult-web--pubmed-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetches results for INPUT from PubMed using Entrez Utilities
service.

COUNT and PAGE are passed to `consult-web--pubmed-esearch-fetch-results' and `consult-web--pubmed-esummary-fetch-results'.

DATABASE is passed as DB to `consult-web--pubmed-esearch-fetch-results' and `consult-web--pubmed-esummary-fetch-results'."
(let* ((esearch (consult-web--pubmed-esearch-fetch-results input))
       (webenv (plist-get esearch :webenv))
       (qk (plist-get esearch :qk)))
  (consult-web--pubmed-esummary-fetch-results input :callback callback :webenv webenv :qk qk)
))


(consult-web-define-source "PubMed"
                           :narrow-char ?p
                           :type 'async
                           :category 'consult-web-scholar
                           :face 'consult-web-scholar-source-face
                           :request #'consult-web--pubmed-fetch-results
                           :preview-key consult-web-preview-key
                           :search-history 'consult-web--search-history
                           :selection-history 'consult-web--selection-history
                           :enabled (lambda () (bound-and-true-p consult-web-pubmed-api-key))
                           :group #'consult-web--group-function
                           :sort t
                           :dynamic 'both
                           :annotate nil
                           )
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-pubmed' module

(provide 'consult-web-pubmed)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-pubmed)
;;; consult-web-pubmed.el ends here
#+end_src


*** Scopus
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-scopus.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-web-scopus.el --- Consulting Scopus -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-web)
#+end_src

**** format
#+begin_src emacs-lisp
(cl-defun consult-web--scopus-format-candidate (&rest args &key source query url search-url title authors date journal doi face &allow-other-keys)
  "Returns a formatted string for candidates of `consult-web-scopus'.

TABLE is a hashtable from `consult-web--scopus-fetch-results'."
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (if (stringp source) (propertize source 'face 'consult-web-source-face) nil))
         (date (if (stringp date) (propertize date 'face 'consult-web-date-face) nil))
         (journal (if (stringp journal) (propertize journal 'face 'consult-web-domain-face) nil))
         (authors (cond
                   ((and authors (listp authors))
                    (concat (first authors) ",..., " (car (last authors))))
                   ((stringp authors)
                    authors)
                   (t nil)
                   ))
         (authors (if (and authors (stringp authors)) (propertize authors 'face 'consult-web-source-face)))
         (doi (if (stringp doi) (propertize doi 'face 'link) nil))
         (match-str (if (stringp query) (consult--split-escaped query) nil))
         (face (or (consult-web--get-source-prop source :face) face 'consult-web-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-web--set-string-width title-str (* 5 frame-width-percent)))
         (str (concat title-str
                      (if journal (format "\t%s" journal))
                      (if date (format "\s\s%s" date))
                      (if authors (format "\s\s%s" authors))
                      (if source (concat "\t" source)))))
    (if consult-web-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-web--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-web--highlight-match match-str str t)))))
    str))
#+end_src
**** callback
#+begin_src emacs-lisp
(defun consult-web--scopus-callback (cand)
  "Callback function for `consult-web-scopus'."
  (let* ((doi (get-text-property 0 :doi cand))
         (url (if doi (consult-web--doi-to-url doi)
                (get-text-property 0 :url cand))))
         (funcall consult-web-default-browse-function url)))
#+end_src
**** preview
#+begin_src emacs-lisp
(defun consult-web--scopus-preview (cand)
   "Preview function for `consult-web-scopus'."
  (let* ((doi (get-text-property 0 :doi cand))
         (url (if doi (consult-web--doi-to-url doi)
                (get-text-property 0 :url cand))))
         (funcall consult-web-default-preview-function url)))
#+end_src
**** main
#+begin_src emacs-lisp
(defvar consult-web-scopus-search-url "https://www.scopus.com/record/display.uri?")

(defvar consult-web-scopus-api-url "https://api.elsevier.com/content/search/scopus")

(defcustom consult-web-scopus-api-key nil
  "Key for Scopus API.

See URL `https://dev.elsevier.com/documentation/SCOPUSSearchAPI.wadl' for more info"
  :group 'consult-web
  :type '(choice (const :tag "Scopus API Key" string)
                 (function :tag "Custom Function")))

(cl-defun consult-web--scopus-fetch-results (input &rest args &key callback &allow-other-keys)
  "Retrieve search results from SCOPUS for INPUT.
"
  (pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and (integerp count) count)
                          (and count (string-to-number (format "%s" count)))
                          consult-web-default-count))
               (page (or (and (integerp page) page)
                         (and page (string-to-number (format "%s" page)))
                         consult-web-default-page))
               (count (min (max count 1) 25))
               (page (* count page))
               (params `(("query" . ,(replace-regexp-in-string " " "+" query))
                         ("count" . ,(format "%s" count))
                         ("start" . ,(format "%s" page))
                         ("apiKey" . ,(consult-web-expand-variable-function consult-web-scopus-api-key))))
               (headers `(("Accept" . "application/json")
                          )))
    (consult-web--fetch-url consult-web-scopus-api-url consult-web-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :headers headers
                            :parser #'consult-web--default-url-parse-buffer
                            :callback
                            (lambda (attrs)
                              (when-let* ((raw-results (map-nested-elt attrs '("search-results" "entry")))
                                          (annotated-results
                                           (mapcar (lambda (item)
                                                     (let*
                                                         ((source "Scopus")
                                                          (title (gethash "dc:title" item))
                                                          (journal (gethash "prism:publicationName" item))
                                                          (volume (gethash "prism:volume" item))
                                                          (pages (gethash "prism:pageRange" item))
                                                          (authors (gethash "dc:creator" item))
                                                          (authors (cond
                                                                    ((stringp authors) (list authors))
                                                                    (t authors)))
                                                          (date (gethash "prism:coverDate" item))
                                                          (eid (gethash "eid" item))
                                                          (doi (gethash "prism:doi" item))
                                                          (url (concat consult-web-scopus-search-url "&eid=" eid "&origin=inward"))

                                                          (search-url (concat consult-web-scopus-search-url "&eid=" eid "&origin=inward"))

                                                          (decorated (consult-web--scopus-format-candidate :source source :query query :url url :search-url search-url :title title :authors authors :date date :journal journal :doi doi)))
                                                       (propertize decorated
                                                                   :source source
                                                                   :url url
                                                                   :title title
                                                                   :search-url search-url
                                                                   :query query
                                                                   :journal journal
                                                                   :volume volume
                                                                   :pages pages
                                                                   :authors authors
                                                                   :date date
                                                                   :doi doi
                                                                   :eid eid)))

                                                   raw-results)))
                                (funcall callback annotated-results))))))


(consult-web-define-source "Scopus"
                           :narrow-char ?s
                           :category 'consult-web-scholar
                           :face 'consult-web-scholar-source-face
                           :type 'async
                           :request #'consult-web--scopus-fetch-results
                           :preview-key consult-web-preview-key
                           :on-preview #'consult-web--scopus-preview
                           :on-return #'identity
                           :on-callback #'consult-web--scopus-callback
                           :search-history 'consult-web--search-history
                           :selection-history 'consult-web--selection-history
                           :enabled (lambda () (bound-and-true-p consult-web-scopus-api-key))
                           :group #'consult-web--group-function
                           :sort t
                           :dynamic 'both
                           :annotate nil
                           )

#+end_src

**** provide and footer

#+begin_src emacs-lisp
;;; provide `consult-web-scopus' module

(provide 'consult-web-scopus)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-scopus)
;;; consult-web-scopus.el ends here
#+end_src
*** StackOverflow
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-stackoverflow.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-web-stackoverflow.el --- Consulting StackOverflow -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-web)
#+end_src

**** format
#+begin_src emacs-lisp
(cl-defun consult-web--stackoverflow-format-candidate (&rest args &key source query url search-url title snippet date answered score face &allow-other-keys)
  "Returns a formatted string for Wikipedia's searches.

SOURCE is the name string of the source for candidate

QUERY is the query string used for searching

URL is a string pointing to url of the candidate

SEARCH-URL is a string pointing to the url for
the search results of QUERY on the SOURCE website

TITLE is the title of the candidate

SNIPPET is a string containing a snippet/description of candidate
"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (and (stringp source) (propertize source 'face 'consult-web-source-face)))
         (date (and (stringp date) (propertize date 'face 'consult-web-date-face)))
         (answered (if answered (propertize consult-web-stackoverflow-answered-mark 'face 'consult-web-domain-face)
                     (propertize consult-web-stackoverflow-unanswered-mark 'face 'error)))
         (score (and score (propertize (format "%s" score) 'face 'consult-web-path-face)))
         (match-str (and (stringp query) (consult--split-escaped query) nil))
         (face (or (consult-web--get-source-prop source :face) face 'consult-web-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-web--set-string-width title-str (* 7 frame-width-percent)))
         (str (concat title-str
                      (when date (concat "\s" date))
                      (when answered (concat "\s" answered))
                      (when score (concat "\s" score))
                      (when source (concat "\t" source)))))
    (if consult-web-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-web--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-web--highlight-match match-str str t)))))
    str))
#+end_src
**** stackoverflow
#+begin_src emacs-lisp
(defvar consult-web-stackoverflow-search-url "https://stackoverflow.com/search")
(defvar consult-web-stackoverflow-api-url "https://api.stackexchange.com/2.3/search/advanced")
(defvar consult-web-stackoverflow-answered-mark "+")
(defvar consult-web-stackoverflow-unanswered-mark "x")

(defcustom consult-web-stackexchange-api-key nil
  "Key for Stack Exchange API.

See URL `https://api.stackexchange.com/', and URL `https://stackapps.com/' for more info"
  :group 'consult-web
  :type '(choice (const :tag "API Key" string)
                 (function :tag "Custom Function")))

(cl-defun consult-web--stackoverflow-fetch-results (input &rest args &key count page order sort &allow-other-keys)
  "Fetch search results for INPUT from StackOverflow.

COUNT is passed as pagesize in query parameters.
PAGE is passed as page in query parameters.
ORDER is passed as order in query parameters.
SORT is passed as sort in query parameters.

See URL `https://api.stackexchange.com/' for more info.
"
  (let* ((count (or (and (integerp count) count)
                    (and count (string-to-number (format "%s" count)))
                    consult-web-default-count))
         (count (min count 25))
         (page (or (and (integerp page) page)
                   (and page (string-to-number (format "%s" page)))
                   consult-web-default-page))
         (page (max page 1))
         (order (if (and order (member (format "%s" order) '("desc" "asc"))) (format "%s" order)))
         (sort (if (and sort (member (format "%s" sort) '("activity" "votes" "creation" "relevance"))) (format "%s" sort)))
         (params `(("order" . ,(or order "desc"))
                   ("sort" . ,(or sort "relevance"))
                   ("site" . "stackoverflow")
                   ("q" . ,(replace-regexp-in-string " " "+" input))
                   ("pagesize" . ,(format "%s" count))
                   ("page" . ,(format "%s" page))
                   ("key" . ,(consult-web-expand-variable-function consult-web-stackexchange-api-key)))))
    (funcall consult-web-retrieve-backend
             consult-web-stackoverflow-api-url
             :params params
             :parser
             (lambda ()
               (goto-char (point-min))
               (let* ((results (gethash "items" (json-parse-buffer)))
                      (data  (mapcar (lambda (item) `(,(format "%s" (gethash "title" item)) ,(format "%s" (gethash "link" item)))) results))
                      (table (make-hash-table :test 'equal)))
                 (cl-loop for a in data
                          collect
                          (let ((table (make-hash-table :test 'equal)))
                            (puthash :url
                                     (cadr a) table)
                            (puthash :search-url (concat consult-web-stackoverflow-search-url "?q=" input)
                                     table)
                            (puthash :title
                                     (car a) table)
                            (puthash :source "StackOverflow"
                                     table)
                            (puthash :query input
                                     table)
                            table

                            )))
               ))))

(cl-defun consult-web--stackoverflow-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results for INPUT from StackOverflow.
See URL `https://api.stackexchange.com/' for more info.
"
  (pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (order (plist-get opts :order))
               (sort (plist-get opts :sort))
               (count (or (and (integerp count) count)
                          (and count (string-to-number (format "%s" count)))
                          consult-web-default-count))
               (page (or (and (integerp page) page)
                         (and page (string-to-number (format "%s" page)))
                         consult-web-default-page))
               (count (min count 25))
               (page (max page 1))
               (order (if (and order (member (format "%s" order) '("desc" "asc"))) (format "%s" order)))
               (sort (if (and sort (member (format "%s" sort) '("activity" "votes" "creation" "relevance"))) (format "%s" sort)))
               (params `(("order" . ,(or order "desc"))
                         ("sort" . ,(or sort "relevance"))
                         ("site" . "stackoverflow")
                         ("q" . ,(replace-regexp-in-string " " "+" query))
                         ("pagesize" . ,(format "%s" count))
                         ("page" . ,(format "%s" page))
                         ("key" . ,(consult-web-expand-variable-function consult-web-stackexchange-api-key))))
               (headers '(("Accept" . "application/json"))))
    (consult-web--fetch-url consult-web-stackoverflow-api-url consult-web-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :headers headers
                            :parser #'consult-web--default-url-parse-buffer
                            :callback
                            (lambda (attrs)
                              (let* ((raw-results (gethash "items" attrs))
                                     (annotated-results
                                      (mapcar (lambda (item)
                                                (let*
                                                    ((source "StackOverflow")
                                                     (url (format "%s" (gethash "link" item)))
                                                     (title (format "%s" (gethash "title" item)))
                                                     (date (gethash "last_edit_date" item))
                                                     (date (format-time-string "%Y-%m-%d" (seconds-to-time date)))
                                                     (answered (gethash "is_answered" item))
                                                     (score (gethash "score" item))
                                                     (search-url (concat consult-web-stackoverflow-search-url "?q=" input))
                                                     (decorated (consult-web--stackoverflow-format-candidate :source source :query query :url url :search-url search-url :title title :date date :answered answered :score score)))
                                                  (propertize decorated
                                                              :source source
                                                              :title title
                                                              :url url
                                                              :search-url search-url
                                                              :query query
                                                              :date date
                                                              :answered answered
                                                              :score score
                                                              )))

                                              raw-results)))
                                (when annotated-results
                                  (funcall callback annotated-results))
                                annotated-results)))))

(consult-web-define-source "StackOverflow"
                           :narrow-char ?s
                           :type 'async
                           :face 'consult-web-engine-source-face
                           :request #'consult-web--stackoverflow-fetch-results
                           :preview-key consult-web-preview-key
                           :search-history 'consult-web--search-history
                           :selection-history 'consult-web--selection-history
                           :dynamic 'both
                           :enabled (lambda () (bound-and-true-p consult-web-stackexchange-api-key))
                           :group #'consult-web--group-function
                           :sort t
                           :dynamic 'both
                           :annotate nil
                           )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-stackoverflow' module

(provide 'consult-web-stackoverflow)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-stackoverflow)
;;; consult-web-stackoverflow.el ends here
#+end_src


*** Wikipedia
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-wikipedia.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-web-wikipedia.el --- Consulting Wikipedia -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-web)
#+end_src
**** format
#+begin_src emacs-lisp
(cl-defun consult-web--wikipedia-format-candidate (&rest args &key source query url search-url title snippet date face &allow-other-keys)
  "Returns a formatted string for Wikipedia's searches.

SOURCE is the name string of the source for candidate

QUERY is the query string used for searching

URL is a string pointing to url of the candidate

SEARCH-URL is a string pointing to the url for
the search results of QUERY on the SOURCE website

TITLE is the title of the candidate

SNIPPET is a string containing a snippet/description of candidate
"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (and (stringp source) (propertize source 'face 'consult-web-source-face)))
         (date (and (stringp date) (propertize date 'face 'consult-web-date-face)))
         (match-str (and (stringp query) (consult--split-escaped query) nil))
         (face (or (consult-web--get-source-prop source :face) face 'consult-web-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-web--set-string-width title-str (* 3 frame-width-percent)))
         (snippet (and (stringp snippet) (consult-web--set-string-width (string-trim snippet) (* 6 frame-width-percent))))
         (snippet (and (stringp snippet) (propertize snippet 'face 'consult-web-snippet-face)))
         (str (concat title-str
                      (when date (concat "\s" date))
                      (when snippet (concat "\s\s" snippet))
                      (when source (concat "\t" source)))))
    (if consult-web-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-web--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-web--highlight-match match-str str t)))))
    str))
#+end_src
**** wikipedia
#+begin_src emacs-lisp
(defvar consult-web-wikipedia-search-url "https://www.wikipedia.org/search-redirect.php")
(defvar consult-web-wikipedia-url "https://wikipedia.org/")
(defvar consult-web-wikipedia-api-url "https://wikipedia.org/w/api.php")

(cl-defun consult-web--wikipedia-fetch-results (input &rest args &key callback &allow-other-keys)
  ""
  (pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and (integerp count) count)
                          (and count (string-to-number (format "%s" count)))
                          consult-web-default-count))
               (page (or (and (integerp page) page)
                         (and page (string-to-number (format "%s" page)))
                         consult-web-default-page))
               (params `(("action" . "query")
                 ("format" . "json")
                 ("list" . "search")
                 ("formatversion" . "2")
                 ("prop" . "info")
                 ("inprop" . "url")
                 ("srwhat" . "text")
                 ("srsearch" . ,(url-hexify-string query))
                 ("srlimit" . ,(format "%s" count))
                 ("sroffset" . ,(format "%s" page))))
               (headers '(("User-Agent" . "Emacs:consult-web/0.1 (https://github.com/armindarvish/consult-web);"))))
    (consult-web--fetch-url consult-web-wikipedia-api-url consult-web-http-retrieve-backend
      :encoding 'utf-8
      :params params
      :headers headers
      :parser #'consult-web--default-url-parse-buffer
      :callback
      (lambda (attrs)
        (when-let* ((raw-results (map-nested-elt attrs '("query" "search")))
                    (annotated-results
                     (mapcar (lambda (item)
                               (let*
                                   ((source "Wikipedia")
                                    (title (format "%s" (gethash "title" item)))
                                    (url (concat consult-web-wikipedia-url "wiki/" (string-replace " " "_" title)))
                                    (date (gethash "timestamp" item))
                                    (date (format-time-string "%Y-%m-%d" (date-to-time date)))
                                    (snippet (replace-regexp-in-string "<span.*?>\\|</span>\\|&quot;" "" (format "%s" (gethash "snippet" item))))
                                    (search-url (concat  consult-web-wikipedia-search-url "?" "search=" query))
                                    (decorated (consult-web--wikipedia-format-candidate :source source :query query :url url :search-url search-url :title title :snippet snippet :date date)))
                                 (propertize decorated
                                             :source source
                                             :title title
                                             :url url
                                             :search-url search-url
                                             :query query
                                             :date date)))

                             raw-results)))
          (funcall callback annotated-results)
          annotated-results)))))


(consult-web-define-source "Wikipedia"
                           :narrow-char ?w
                           :type 'async
                           :face 'consult-web-engine-source-face
                           :request #'consult-web--wikipedia-fetch-results
                           :preview-key consult-web-preview-key
                           :search-history 'consult-web--search-history
                           :selection-history 'consult-web--selection-history
                           :enabled (lambda () (boundp  'consult-web-wikipedia-api-url))
                           :group #'consult-web--group-function
                           :sort t
                           :type 'async
                           :dynamic 'both
                            )
#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-wikipedia' module

(provide 'consult-web-wikipedia)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-wikipedia)
;;; consult-web-wikipedia.el ends here
#+end_src
*** YouTube
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-web-youtube.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-web-youtube.el --- Consulting YouTube -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: ((emacs "28.1") (consult "1.1"))
;; Homepage: https://github.com/armindarvish/consult-web
;; Keywords: convenience

;;; Commentary:

;;; Code:

(require 'consult-web)
#+end_src
**** format
#+begin_src emacs-lisp
(cl-defun consult-web--youtube-format-candidate (&rest args &key source query title snippet channeltitle date face &allow-other-keys)
"Formats a candidate for `consult-web-youtube' commands.
"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (propertize source 'face 'consult-web-source-face))
         (match-str (if (stringp query) (consult--split-escaped query) nil))
         (date (and (stringp date) (propertize date 'face 'consult-web-date-face)))
         (channeltitle (and (stringp channeltitle) (propertize channeltitle 'face 'consult-web-path-face)))
         (snippet (if (stringp snippet) (consult-web--set-string-width snippet (* 2 frame-width-percent))))
         (snippet (and (stringp snippet) (propertize snippet 'face 'consult-web-snippet-face)))
         (face (or (consult-web--get-source-prop source :face) face 'consult-web-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-web--set-string-width title-str (* 6 frame-width-percent)))
         (str (concat title-str
                      (when date (concat "\s" date))
                      (when channeltitle (concat " " channeltitle))
                      (when snippet (concat "\s\s" snippet))
                      (concat "\t" source)))
         )
    (if consult-web-highlight-matches
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-web--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-web--highlight-match match-str str t)))))
    str))
#+end_src
**** youtube
#+begin_src emacs-lisp
(defvar consult-web-youtube-watch-url "https://www.youtube.com/watch")

(defvar consult-web-youtube-channel-url "https://www.youtube.com/channel/")

(defvar consult-web-youtube-search-results-url "https://www.youtube.com/results")

(defvar consult-web-youtube-search-api-url "https://www.googleapis.com/youtube/v3/search")

(defcustom consult-web-youtube-search-key nil
  "Key for “YouTube Data API”

See URL `https://developers.google.com/youtube/v3/getting-started'
for details"
  :group 'consult-web
  :type '(choice (const :tag "API Key" string)
                 (function :tag "Custom Function")))

(cl-defun consult-web--youtube-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetches search results for INPUT from “YouTube Data API” service.
"
  (pcase-let* ((`(,query . ,opts) (consult-web--split-command input))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (def (plist-get opts :def))
               (type (plist-get opts :type))
               (vidtype (plist-get opts :vidtype))
               (order (plist-get opts :order))
               (count (or (and (integerp count) count)
                    (and count (string-to-number (format "%s" count)))
                    consult-web-default-count))
         (page (or (and (integerp page) page)
                   (and page (string-to-number (format "%s" page)))
                   consult-web-default-count))
               (def (if (and def (member (format "%s" def) '("any" "standard" "high"))) (format "%s" def) "any"))
               (type (if (and type (member (format "%s" type) '("channel" "playlist" "video"))) (format "%s" type) "video"))
               (vidtype (if (and vidtype (member (format "%s" vidtype) '("any" "episode" "movie"))) (format "%s" vidtype) "any"))
               (count (min count 10))
               (page (+ (* page count) 1))
               (order  (if (and order (member (format "%s" order) '("date" "rating" "relevance" "title" "videoCount" "viewCount"))) (format "%s" order) "relevance"))
               (params `(("q" . ,(replace-regexp-in-string " " "+" query))
                         ("part" . "snippet")
                         ("order" . ,order)
                         ("type" . ,type)
                         ("maxResults" . ,(format "%s" count))
                         ("videoDefinition" . ,def)
                         ("videoType" . ,vidtype)))
               (headers `(("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("User-Agent" . "consult-web (gzip)")
                          ("X-Goog-Api-Key" . ,(consult-web-expand-variable-function consult-web-youtube-search-key)))))
    (consult-web--fetch-url consult-web-youtube-search-api-url consult-web-http-retrieve-backend
                            :encoding 'utf-8
                            :params params
                            :headers headers
                            :parser #'consult-web--default-url-parse-buffer
                            :callback
                            (lambda (attrs)
                              (let* ((raw-results (gethash "items" attrs))
                                     (annotated-results
                                      (mapcar (lambda (item)
                                                (let*
                                                    ((source "YouTube")
                                                     (videoid (gethash "videoId" (gethash "id" item)))
                                                     (snippet (gethash "snippet" item))
                                                     (channeltitle (gethash "channelTitle" snippet))
                                                     (channelid (gethash "channelId" snippet))
                                                     (title (gethash "title" snippet))
                                                     (date (gethash "publishedAt" snippet))
                                                     (date (format-time-string "%Y-%m-%d %R" (date-to-time date)))
                                                     (url (cond
                                                           (videoid (consult-web--make-url-string consult-web-youtube-watch-url `(("v" . ,videoid))))
                                                           (channelid (concat consult-web-youtube-channel-url channelid))))
                                                     (search-url (consult-web--make-url-string consult-web-youtube-search-results-url `(("search_query" . ,query))))
                                                     (description (gethash "description" snippet))

                                                     (decorated (consult-web--youtube-format-candidate :source source :query query :title title :snippet snippet :channeltitle channeltitle :date date))

                                                     ;; (decorated (funcall consult-web-default-format-candidate :source source :query query :url url :search-url search-url :title title :snippet snippet :face 'consult-web-engine-source-face))
                                                     )
                                                (propertize decorated
                                                            :source source
                                                            :title title
                                                            :url url
                                                            :search-url search-url
                                                            :query query
                                                            :snippet description
                                                            :videoid videoid
                                                            :channeltitle channeltitle
                                                            :channelid channelid)))

                                      raw-results)))
                              (when annotated-results
                                (funcall callback annotated-results))
                              annotated-results)))))

(consult-web-define-source "YouTube"
                           :narrow-char ?y
                           :type 'async
                           :category 'consult-web-video
                           :face 'consult-web-engine-source-face
                           :request #'consult-web--youtube-fetch-results
                           :format #'consult-web--youtube-format-candidate
                           :preview-key consult-web-preview-key
                           :search-history 'consult-web--search-history
                           :selection-history 'consult-web--selection-history
                           :enabled (lambda () (bound-and-true-p consult-web-youtube-search-key))
                           :group #'consult-web--group-function
                           :sort t
                           :dynamic 'both
                           :annotate nil
                           )

#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-web-youtube' module

(provide 'consult-web-youtube)

(add-to-list 'consult-web-sources-modules-to-load 'consult-web-youtube)
;;; consult-web-youtube.el ends here
#+end_src
