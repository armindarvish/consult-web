
* consult-web
#+begin_src emacs-lisp
(defun cw--group-function (sources cand transform)
  "Group candidates by GROUP-BY keyword.

This is passed as GROUP to `consult--read' on candidates and is used to define the grouping for CAND. "
  (if transform (substring cand)
    (let* ((group-by (or consult-web--override-group-by consult-web-group-by))
           (group-by (if (not (keywordp group-by)) (intern (concat ":" (format "%s" group-by))) group-by)))
      (cond
       ((equal group-by :domain)
        (if-let* ((url (get-text-property 0 :url cand))
                  (urlobj (if url (url-generic-parse-url url) nil))
                  (domain (if (url-p urlobj) (url-domain urlobj))))
            domain
          nil))
       ((member group-by '(:nil :none :no :not))
        nil)
       (group-by
        (if-let ((group (get-text-property 0 group-by cand)))
            group
          "N/A"))
       (t
        (if-let* ((source (plist-get (consult--multi-source sources cand) :name)))
            source
          nil)))
      )))

(defun cw--multi-group (sources cand transform)
  "Return title of candidate CAND or TRANSFORM the candidate given SOURCES."
  (if transform cand
    (let* ((fun (and (plist-member (consult--multi-source sources cand) :group)
                     (plist-get (consult--multi-source sources cand) :group))))
      (cond
       ((functionp fun)
        (funcall fun sources cand transform))
       ((stringp fun)
        fun)
       ((eq fun 'nil)
        nil)
       (t
        (plist-get (consult--multi-source sources cand) :name))))))


(defun cw--multi-async (async sources)
  "Merge the results of (a)sync SOURCES and pass it to function ASYNC."
  (let ((candidates (make-vector (length sources) nil)))
    (lambda (action)
      (pcase action
        ((pred stringp)
         (unless (equal action "")
           (let ((idx 0))
             (seq-doseq (src sources)
               (let* ((face (and (plist-member src :face) `(face ,(plist-get src :face))))
                      (cat (plist-get src :category))
                      (items (plist-get src :items))
                      (narrow (plist-get src :narrow))
                      (type (or (car-safe narrow) narrow -1))
                      (pos idx))
                 (when (or (eq consult--narrow type)
                           (not (or consult--narrow (plist-get src :hidden))))
                   (condition-case nil
                       (progn
                         (when (functionp items) (setq items (funcall items action)))
                         (aset candidates idx    ; sync source, refresh now
                               (and items (cw--multi-propertize
                                           items cat idx face)))
                         (funcall async 'flush)
                         (funcall async (apply #'append (append candidates nil))))
                     (wrong-number-of-arguments
                      (funcall items action      ; async source, refresh in callback
                               (lambda (response-items)
                                 (when response-items
                                   (aset candidates pos
                                         (cw--multi-propertize response-items cat pos face))
                                   (funcall async 'flush)
                                   (funcall async (apply #'append (append candidates nil))))))))))
               (cl-incf idx)))))
        (_ (funcall async action))))))

(defun cw--multi-propertize (response-items category pos &optional face)
  "Propertize RESPONSE-ITEMS with the multi-category datum and FACE.

POS and CATEGORY are the group ID and category for these items."
  (let ((annotated-items))
    (dolist (item response-items annotated-items)
      (let ((cand (consult--tofu-append item pos)))
        ;; Preserve existing `multi-category' datum of the candidate.
        (if (get-text-property 0 'multi-category cand)
            (when face (add-text-properties 0 (length item) face cand))
          ;; Attach `multi-category' datum and face.
          (add-text-properties 0 (length item)
                               `(multi-category (,category . ,item) ,@face) cand))
        (push cand annotated-items)))))

(defun cw--annotate (sources cand)
  (let ((src (consult--multi-source sources cand)))
    (if-let ((fun (plist-get src :annotate)))
        (funcall fun (cdr (get-text-property 0 'multi-category cand)))
      (plist-get src :name)
      )))

(defun cw--multi (sources &rest options)
  (let* ((sources (consult--multi-enabled-sources sources))
         (selected
          (apply #'consult--read
                 (consult--async-split
                  (consult--async-throttle
                   (cw--multi-async
                    (consult--async-refresh-timer
                     (consult--async-sink))
                    sources)))
                 (append
                  options
                  (list
                   :sort        t
                   :history     'cw--search-history
                   :initial     (consult--async-split-initial nil)
                   :category    'multi-category
                   :predicate   (apply-partially #'consult--multi-predicate sources)
                   :annotate    (apply-partially #'cw--annotate sources)
                   :group       (apply-partially #'cw--multi-group sources)
                   :lookup      (apply-partially #'consult--multi-lookup sources)
                   :preview-key (consult--multi-preview-key sources)
                   :narrow      (consult--multi-narrow sources)
                   :state       (consult--multi-state sources))))))
    (if (plist-member (cdr selected) :match)
        (when-let (fun (plist-get (cdr selected) :new))
          (funcall fun (car selected))
          (plist-put (cdr selected) :match 'new))
      (when-let (fun (plist-get (cdr selected) :action))
        (funcall fun (car selected)))
      (setq selected `(,(car selected) :match t ,@(cdr selected))))
    selected))

#+end_src


* my consult-web-mini
#+begin_src emacs-lisp :lexical t
;;; Code:
(require 'consult)
(require 'plz)

(defun cw--multi-async (async sources)
  "Merge the results of (a)sync SOURCES and pass it to function ASYNC."
  (let ((candidates (make-vector (length sources) nil)))
    (lambda (action)
      (pcase action
        ((pred stringp)
         (unless (equal action "")
           (let ((idx 0))
             (seq-doseq (src sources)
               (let* ((face (and (plist-member src :face) `(face ,(plist-get src :face))))
                      (cat (plist-get src :category))
                      (items (plist-get src :items))
                      (narrow (plist-get src :narrow))
                      (type (or (car-safe narrow) narrow -1))
                      (pos idx))
                 (when (or (eq consult--narrow type)
                           (not (or consult--narrow (plist-get src :hidden))))
                   (condition-case nil
                       (progn
                         (when (functionp items) (setq items (funcall items action)))
                         (setq candidates (append candidates items))


                         ;; (aset candidates idx    ; sync source, refresh now
                         ;;       (and items (cw--multi-propertize
                         ;;                   items cat idx face)))
                         (funcall async 'flush)
                         (funcall async (apply #'append (append candidates nil))))
                     (wrong-number-of-arguments
                      (funcall items action      ; async source, refresh in callback
                               (lambda (response-items)
                                 (when response-items
                                   (aset candidates pos
                                         (cw--multi-propertize response-items cat pos face))
                                   (funcall async 'flush)
                                   (funcall async (apply #'append (append candidates nil))))))))))
               (cl-incf idx)))))
        (_ (funcall async action))))))

(defun cw--multi-propertize (response-items category pos &optional face)
  "Propertize RESPONSE-ITEMS with the multi-category datum and FACE.

POS and CATEGORY are the group ID and category for these items."
  (let ((annotated-items))
    (dolist (item response-items annotated-items)
      (let ((cand (consult--tofu-append item pos)))
        ;; Preserve existing `multi-category' datum of the candidate.
        (if (get-text-property 0 'multi-category cand)
            (when face (add-text-properties 0 (length item) face cand))
          ;; Attach `multi-category' datum and face.
          (add-text-properties 0 (length item)
                               `(multi-category (,category . ,item) ,@face) cand))
        (push cand annotated-items)))))

(defun cw--annotate (sources cand)
  (let ((src (consult--multi-source sources cand)))
    (if-let ((fun (plist-get src :annotate)))
        (funcall fun (cdr (get-text-property 0 'multi-category cand)))
      (plist-get src :name))))

(defun cw--multi (sources &rest options)
  (let* ((sources (consult--multi-enabled-sources sources))
         (selected
          (apply #'consult--read
                 (consult--async-split
                  (consult--async-throttle
                   (cw--multi-async
                    (consult--async-refresh-timer
                     (consult--async-sink))
                    sources)))
                 (append
                  options
                  (list
                   :sort        nil
                   :history     'cw--search-history
                   :initial     (consult--async-split-initial nil)
                   :category    'multi-category
                   :predicate   (apply-partially #'consult--multi-predicate sources)
                   :annotate    (apply-partially #'cw--annotate sources)
                   :group       (apply-partially #'consult--multi-group sources)
                   :lookup      (apply-partially #'consult--multi-lookup sources)
                   :preview-key (consult--multi-preview-key sources)
                   :narrow      (consult--multi-narrow sources)
                   :state       (consult--multi-state sources))))))
    (if (plist-member (cdr selected) :match)
        (when-let (fun (plist-get (cdr selected) :new))
          (funcall fun (car selected))
          (plist-put (cdr selected) :match 'new))
      (when-let (fun (plist-get (cdr selected) :action))
        (funcall fun (car selected)))
      (setq selected `(,(car selected) :match t ,@(cdr selected))))
    selected))


;;; Commands
(defun cw-search ()
  (interactive)
  (let ((consult-async-input-throttle 0.7)
        (consult-async-input-debounce 0.4))
    (cw--multi (list cw-source-elfeed cw-source-gptel
                     cw-source-brave cw-source-wombag
                     cw-source-browser-hist
                     cw-source-invidious)
               :prompt "Search: "

               )))

(defun cw-search-local ()
  (interactive)
  (let ((consult-async-input-throttle 0.7)
        (consult-async-input-debounce 0.4))
    (cw--multi (list cw-source-elfeed
                     cw-source-wombag
                     cw-source-browser-hist)
               :prompt "Search (local sources): "
               )))

;;; Convenience
(defvar cw--search-history nil
  "History variable for `cw-search' and co.")

(defvar cw--count 5
  "Max number of results per source.")

;;; Sources
;;;; gptel
(defvar cw-source-gptel
  `(:name     "gptel"
              :narrow   ?g
              :category 'consult-web
              :face     font-lock-operator-face
              :annotate ,#'cw-gptel-annotate
              :state    ,#'cw--gptel-state
              :items    ,#'cw--gptel-request
              :preview-key ,consult-web-preview-key
              :enabled  ,(lambda () (fboundp 'gptel))))

(defun cw--gptel-state ()
  "gptel result preview function."
  (let ((query-sent) (buffer-preview (consult--buffer-preview)))
    (lambda (action cand)
      (pcase action
        ('exit (funcall buffer-preview 'exit cand))
        ((or 'preview 'return)
         (if cand
             (let* ((props (text-properties-at 0 cand))
                    (query (plist-get props :query))
                    (gptel-buffer (gptel "*cw-gptel*")))
               (with-current-buffer gptel-buffer
                 (unless query-sent
                   (erase-buffer)
                   (insert (gptel-prompt-prefix-string) query)
                   (setq query-sent t)
                   (gptel-send)))
               (funcall buffer-preview 'preview gptel-buffer))
           (funcall buffer-preview 'preview cand)))))))

(defun cw--gptel-request (query callback)
  ""
  (let ((gptel-max-tokens 24)
        (gptel-use-curl))
    (gptel-request query
      :system "Respond in 10 words or less."
      :callback
      (lambda (response _)
        (when response
          (setq response
                (propertize (string-trim-right response)
                            :title response
                            :source "gptel"
                            :query query
                            :model gptel-model
                            :stream gptel-stream
                            :backend (gptel-backend-name gptel-backend)))
          (funcall callback (list response)))))))


(cl-defun cw--gptel-request (query callback)
  ""
 (pcase-let* ((`(,input . ,opts) (consult--command-split query))
               (remaining-opts (list))
               (args (list))
               )
    (if (and query input) (setq cw-gptel-query input))
    (cl-loop for opt in opts
             do
             (pcase-let* ((`(,key . ,val) (consult-web--extract-opt-pair opt opts (list "--group" ":group"))))

               (when key
                 (setq args (append args (list key val)))
                 (setq remaining-opts (cl-delete-duplicates (append remaining-opts (list opt (format "%s" val))))))
               )))

  (let* ((model (or (plist-get args :model) nil))
         (backend (or (plist-get args :backend) nil))
         (backend (and backend (car (seq-filter (lambda (item) (when (string-match (format "%s" backend) item) item)) (mapcar #'car gptel--known-backends)))))
         (backend (or backend (gptel-backend-name gptel-backend)))
         (backend-struct  (cdr (assoc (format "%s" backend) gptel--known-backends)))
         (model (if model (format "%s" model)))
         (model (or (and model backend-struct (member model (cl-struct-slot-value (type-of backend-struct) 'models backend-struct)) model)
                    (and model gptel-backend (member model (cl-struct-slot-value (type-of gptel-backend) 'models gptel-backend)) model)
                    (and backend-struct (car (cl-struct-slot-value (type-of backend-struct) 'models backend-struct)))
                    (and gptel-backend (car (cl-struct-slot-value (type-of gptel-backend) 'models gptel-backend)))))
         (gptel-model (or model gptel-model))
         (gptel-backend (or backend-struct gptel-backend))
         (gptel-max-tokens 24)
         (gptel-use-curl))
    (gptel-request cw-gptel-query
        :system "Respond in 10 words or less."
        :callback
        (lambda (response _)
          (when response
            (setq response
                  (propertize (string-trim-right response)
                              :title response
                              :source "gptel"
                              :query cw-gptel-query
                              :model gptel-model
                              :stream gptel-stream
                              :backend (gptel-backend-name gptel-backend))))
          (funcall callback (list response))))))

(defun cw-gptel-annotate (cand)
  ""
  (let* ((props (text-properties-at 0 cand))
         (model (plist-get props :model))
         (stream (plist-get props :stream))
         (backend (plist-get props :backend)))
    (concat " " (propertize " " 'display '(space :align-to center))
            (propertize backend 'face 'font-lock-variable-name-face)
            (propertize (format ":%s" model) 'face 'font-lock-warning-face)
            (and stream (propertize " ~stream~ " 'face 'font-lock-comment-face)))))

;;;; brave
(defvar cw-source-brave
  `(:name     "Brave"
              :narrow   ?b
              :category consult-web
              :state    ,#'cw--brave-state
              :items    ,#'cw--brave-request
              :preview-key ,consult-web-preview-key
              :enabled  ,(lambda () cw-brave-api-key)))

(defun cw--eww-readable-once ()
  (eww-readable)
  (remove-hook 'eww-after-render-hook #'cw--eww-readable-once))

(defun cw--brave-state ()
  (let ((buffer-preview (consult--buffer-preview)))
    (lambda (action cand)
      (pcase action
        ('exit (funcall buffer-preview 'exit cand))
        ((or 'preview 'return)
         (if cand
             (when-let* ((props (text-properties-at 0 cand))
                         (url (or (plist-get props :url)
                                  (plist-get props :search-url))))
               (if (eq action 'preview)
                   (progn
                     (add-hook 'eww-after-render-hook #'cw--eww-readable-once)
                     (funcall buffer-preview 'preview (eww-browse-url url)))
                 (browse-url url)))
           (funcall buffer-preview 'preview cand)))))))

(defun cw--brave-request (query callback)
  (apply
   #'plz 'get (cw-brave-url-string query)
   (cw-brave-query-args
       (lambda (attrs)
         (when-let* ((raw-results (map-nested-elt attrs '(:web :results)))
                     (annotated-results
                      (mapcar
                       (lambda (item)
                         (let* ((title (map-elt item :title))
                                (search-url (cw-brave-url-string query))
                                (url (map-elt item :url))
                                (urlobj (and url (url-generic-parse-url url)))
                                (domain (and (url-p urlobj) (url-domain urlobj)))
                                (domain (and (stringp domain)
                                             (propertize domain 'face 'font-lock-variable-name-face)))
                                (path (and (url-p urlobj) (url-filename urlobj)))
                                (path (and (stringp path)
                                           (propertize path 'face 'font-lock-warning-face)))
                                (decorated (concat title "\t"
                                                   (propertize " " 'display '(space :align-to center))
                                                   domain path
                                                   )))
                           (propertize decorated
                                       :title title
                                       :url url
                                       :search-url search-url
                                       :query query)))
                       raw-results)))
           (funcall callback annotated-results))))))

(defvar cw-brave-url "https://api.search.brave.com/res/v1/web/search")
(defvar cw-brave-api-key nil)
(setq cw-brave-api-key #'my:brave-key)

(defun cw-brave-url-string (query)
  (concat cw-brave-url "?"
          (url-build-query-string
           `(("q" ,(url-hexify-string query))
             ("count" ,(format "%s" cw--count))
             ("page" ,(format "%s" 0))))))

(defun cw-brave-query-args (plz-callback)
  (declare (indent 1))
  (list :headers `(("User-Agent" . "Emacs:consult-web/0.1 (Emacs consult-web package; https://github.com/armindarvish/consult-web)")
                   ("Accept" . "application/json")
                   ("Accept-Encoding" . "gzip")
                   ("X-Subscription-Token" . ,(let ((key cw-brave-api-key))
                                                (if (functionp key) (funcall key) key))))
        :as (lambda () (json-parse-buffer :object-type 'plist))
        :then plz-callback
        :else (lambda (plz-error) (message "%S" plz-error))))

;;;; Elfeed
(defvar cw-source-elfeed
  `(:name     "Elfeed"
              :narrow   ?e
              :category consult-web
              :items    ,#'cw--elfeed-search
              :preview-key ,consult-web-preview-key
              :state    ,#'cw--elfeed-state
              :enabled  ,(lambda () (boundp 'elfeed-db))))

(defun cw--elfeed-state ()
  (let ((buffer-preview (consult--buffer-preview)))
    (lambda (action cand)
      (pcase action
        ('exit (funcall buffer-preview 'exit cand))
        ((or 'preview 'return)
         (if cand
             (when-let* ((entry (get-text-property 0 :entry cand))
                         (buf (elfeed-show-entry entry)))
               (funcall buffer-preview 'preview buf))
           (funcall buffer-preview 'preview nil)))))))

(defun cw--elfeed-search (query)
  (let* ((elfeed-search-filter (concat (format "#%d " cw--count) query))
         (filter (elfeed-search-parse-filter elfeed-search-filter))
         (head (list nil)) (tail head) (count 0)
         (lexical-binding t)
         (search-func (byte-compile (elfeed-search-compile-filter filter))))
    (with-elfeed-db-visit (entry feed)
      (when (funcall search-func entry feed count)
        (setf (cdr tail) (list entry)
              tail (cdr tail)
              count (1+ count))))
    (when-let ((entries (cdr head)))
      (cw-elfeed-annotate entries))))

(defun cw-elfeed-annotate (entries)
  (let ((annotated-entries))
    (dolist (entry entries annotated-entries)
      (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
             (title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
             (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
             (feed (elfeed-entry-feed entry))
             (feed-title
              (when feed
                (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
             (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
             (tags-str (mapconcat
                        (lambda (s) (propertize s 'face 'elfeed-search-tag-face))
                        tags ","))
             (title-width ;; (- (window-width) 20 elfeed-search-trailing-width)
              60
              )
             (title-column (elfeed-format-column
                            title (elfeed-clamp
                                   elfeed-search-title-min-width
                                   title-width
                                   elfeed-search-title-max-width)
                            :left)))
        (push (propertize
               (concat (propertize date 'face 'elfeed-search-date-face) " "
                       (propertize title-column 'face title-faces 'kbd-help title)
                       (when feed-title
                         (concat (propertize feed-title 'face 'elfeed-search-feed-face) " "))
                       (when tags (concat "(" tags-str ")")))
               :entry entry
               :url (elfeed-entry-link entry))
              annotated-entries)))))

;;;; Wombag
(defvar cw-source-wombag
  `(:name     "Wallabag"
              :narrow   ?w
              :category consult-web
              :items    ,#'cw--wombag-search
              :state    ,#'cw--wombag-state
              :enabled  ,(lambda () (featurep 'wombag-search))))

(defun cw--wombag-search (query)
  (let* ((wombag-search-filter (concat (format "#%d " cw--count) query))
         (filter (wombag-search-parse-filter
                  wombag-search-filter wombag-search-columns))
         (entries (wombag-db-get-entries filter wombag-search-columns)))
    (when entries
      (let ((wombag-search-title-width 60))
        (mapcar (lambda (entry) (propertize (wombag-search-format-entry entry)
                                            :entry entry
                                            :url (alist-get 'url entry)))
                entries)))))

(defun cw--wombag-state ()
  (let ((buffer-preview (consult--buffer-preview)))
    (lambda (action cand)
      (pcase action
        ('exit (funcall buffer-preview 'exit cand))
        ((or 'preview 'return)
         (if cand
             (when-let* ((entry (get-text-property 0 :entry cand))
                         (buf (wombag-show-entry entry)))
               (funcall buffer-preview 'preview buf))
           (funcall buffer-preview 'preview nil)))))))

;;;; Browser hist
(defvar cw-source-browser-hist
  `(:name     "Browser history"
              :narrow   ?h
              :category consult-web
              :items    ,#'cw--browser-hist-search
              :state    ,#'cw--brave-state
              :enabled  ,(lambda () (fboundp 'browser-hist-search))))

(defun cw--browser-hist-search (query)
  (when (require 'browser-hist nil t)
    (when-let ((results (browser-hist--send-query query)))
      (mapcar (pcase-lambda (`(,url . ,title))
                (let* ((urlobj (and url (url-generic-parse-url url)))
                       (domain (and (url-p urlobj) (url-domain urlobj)))
                       (domain (and (stringp domain)
                                    (propertize domain 'face 'font-lock-variable-name-face)))
                       (path (and (url-p urlobj) (url-filename urlobj)))
                       (path (and (stringp path)
                                  (propertize path 'face 'font-lock-warning-face)))
                       (decorated (concat
                                   (truncate-string-to-width (or title url) (floor (window-width) 2))
                                   "\t"
                                   (propertize " " 'display '(space :align-to center))
                                   domain path)))
                  (propertize decorated
                              :title title
                              :url url
                              :query query)))
              results))))


;;;; Invidious
(defvar cw-source-invidious
  `(:name     "Youtube"
              :narrow   ?y
              :category consult-web
              :items    ,#'cw--invidious-search
              :state    ,#'cw--brave-state
              :hidden   t))


(defface cw--invidious-published-face
  '((((class color) (background light)) (:foreground "#a0a"))
    (((class color) (background dark))  (:foreground "#7a7")))
  "Face used for the video published date.")

(defface cw--invidious-author-face
  '((((class color) (background light)) (:foreground "#aa0"))
    (((class color) (background dark))  (:foreground "#ff0")))
  "Face used for channel names.")

(defface cw--invidious-length-face
  '((((class color) (background light)) (:foreground "#aaa"))
    (((class color) (background dark))  (:foreground "#77a")))
  "Face used for the video length.")

(defvar cw--invidious-servers nil)

(defun cw--invidious-state ()
  (let ((buffer-preview (consult--buffer-preview)))
    (lambda (action cand)
      (pcase action
        ('exit (funcall buffer-preview 'exit cand))
        ((or 'preview 'return)
         (if cand
             (when-let* ((props (text-properties-at 0 cand))
                         (url (or (plist-get props :url)
                                  (plist-get props :search-url))))
               (if (eq action 'preview)
                   (progn
                     (add-hook 'eww-after-render-hook #'cw--eww-readable-once)
                     (funcall buffer-preview 'preview (eww-browse-url url)))
                 (browse-url url)))
           (funcall buffer-preview 'preview cand)))))))

(defun cw--get-invidious-servers (&optional rotate)
  (when (and cw--invidious-servers rotate)
    (setq cw--invidious-servers
          (nconc (cdr cw--invidious-servers)
                 (list (car cw--invidious-servers)))))
  (or cw--invidious-servers
      (setq cw--invidious-servers
            (when-let ((raw
                        (plz 'get (concat "https://api.invidious.io/instances.json"
                                          "?pretty=1&sort_by=type,users")
                          :then 'sync)))
              (thread-last
                (json-parse-string raw :object-type 'plist :array-type 'list)
                (cl-remove-if-not (lambda (s) (eq t (plist-get (cadr s) :api))))
                (mapcar #'car))))))

(defun cw--invidious-search (terms callback)
  (let* ((params (url-build-query-string
                  `(("q" ,terms)
                    ("page" "1")
                    ;; Fields are ignored right now, this is for the future
                    ("fields" "title,videoId,author,authorId,authorUrl,lengthSeconds,published")
                    ;; ("type" "video" "playlist")
                    ("sort_by" "relevance"))))
         (api-url (car (cw--get-invidious-servers)))
         (query-url (concat api-url "/api/v1/search?" params)))
    (plz 'get query-url
      :as (lambda () (json-parse-buffer :object-type 'plist))
      :then
      (lambda (response)
        "Return list of candidates to cw."
        (when response
          (thread-last response
                       ;; (seq-take response cw--count)
                       (mapcar
                        (lambda (result)
                          (pcase (plist-get result :type)
                            ("channel"
                             (propertize
                              (concat (propertize "[CHANNEL] "
                                                  'face 'cw--invidious-published-face)
                                      " " (truncate-string-to-width (plist-get result :description) 60) " "
                                      (propertize " " 'display `(space :align-to ,(floor (* (window-width) 3) 5)))
                                      (propertize (if-let ((subs (plist-get result :subCount)))
                                                      (format "%4s subs" (file-size-human-readable subs 'si))
                                                    (make-string 11 ? ))
                                                  'face 'cw--invidious-length-face)
                                      " " (truncate-string-to-width
                                           (propertize (plist-get result :author)
                                                       'face 'cw--invidious-author-face)
                                           40 nil ? ))
                              :url (format "https://www.youtube.com/%s/videos" (plist-get result :channelHandle))
                              :author-url (format "https://www.youtube.com%s" (plist-get result :authorUrl))))
                            ("playlist"
                             (propertize
                              (concat (propertize "[PLAYLIST]"
                                                  'face 'cw--invidious-published-face)
                                      " " (plist-get result :title) " "
                                      (propertize " " 'display `(space :align-to ,(floor (* (window-width) 3) 5)))
                                      (propertize (format "%4d Videos " (plist-get result :videoCount))
                                                  'face 'cw--invidious-length-face)
                                      " " (truncate-string-to-width
                                           (propertize (plist-get result :author)
                                                       'face 'cw--invidious-author-face)
                                           40 nil ? ))
                              :url (format "https://www.youtube.com/watch?list=%s"
                                           (plist-get result :playlistId))
                              :author-url (format "https://www.youtube.com%s"
                                                  (plist-get result :authorUrl))))
                            ("video"
                             (propertize
                              (concat (propertize
                                       (format-time-string
                                        "%Y-%m-%d"
                                        (if-let ((published (plist-get result :published)))
                                            (seconds-to-time published) 0))
                                       'face 'cw--invidious-published-face)
                                      " " (plist-get result :title) " "
                                      (propertize " " 'display `(space :align-to ,(- (floor (* (window-width) 3) 5)
                                                                                     12)))
                                      (and-let* ((duration (plist-get result :lengthSeconds))
                                                 (hours (floor duration 3600))
                                                 (minutes (floor (mod duration 3600) 60))
                                                 (seconds (mod duration 60)))
                                        (propertize
                                         (format "(%02d:%02d:%02d) " hours minutes seconds)
                                         'face 'cw--invidious-length-face))
                                      (propertize
                                       (if-let ((views (plist-get result :viewCount)))
                                           (format "%4s views" (file-size-human-readable views 'si))
                                         (make-string 11 ? ))
                                       'face 'cw--invidious-length-face)
                                      " " (truncate-string-to-width
                                           (propertize (plist-get result :author)
                                                       'face 'cw--invidious-author-face)
                                           40 nil ? ))
                              :url (format "https://www.youtube.com/watch?v=%s"
                                           (plist-get result :videoId))
                              :author-url (format "https://www.youtube.com%s"
                                                  (plist-get result :authorUrl)))))))
                       (seq-filter (lambda (result) (not (null result))))
                       (funcall callback)))))))

;;; Feature

(provide 'cw)
;;; cw.el ends here


;; Local Variables:
;; eval: (outline-minor-mode 1)
;; End

#+end_src

#+RESULTS:
: cw

* consult-web-mini
#+begin_src emacs-lisp :lexical t
;;; Code:
(require 'consult)
(require 'plz)

(defun cw--multi-async (async sources)
  "Merge the results of (a)sync SOURCES and pass it to function ASYNC."
  (let ((candidates (make-vector (length sources) nil)))
    (lambda (action)
      (pcase action
        ((pred stringp)
         (unless (equal action "")
           (let ((idx 0))
             (seq-doseq (src sources)
               (let* ((face (and (plist-member src :face) `(face ,(plist-get src :face))))
                      (cat (plist-get src :category))
                      (items (plist-get src :items))
                      (narrow (plist-get src :narrow))
                      (type (or (car-safe narrow) narrow -1))
                      (pos idx))
                 (when (or (eq consult--narrow type)
                           (not (or consult--narrow (plist-get src :hidden))))
                   (condition-case nil
                       (progn
                         (when (functionp items) (setq items (funcall items action)))
                         (aset candidates idx    ; sync source, refresh now
                               (and items (cw--multi-propertize
                                           items cat idx face)))
                         (funcall async 'flush)
                         (funcall async (apply #'append (append candidates nil))))
                     (wrong-number-of-arguments
                      (funcall items action      ; async source, refresh in callback
                               (lambda (response-items)
                                 (when response-items
                                   (aset candidates pos
                                         (cw--multi-propertize response-items cat pos face))
                                   (funcall async 'flush)
                                   (funcall async (apply #'append (append candidates nil))))))))))
               (cl-incf idx)))))
        (_ (funcall async action))))))

(defun cw--multi-propertize (response-items category pos &optional face)
  "Propertize RESPONSE-ITEMS with the multi-category datum and FACE.

POS and CATEGORY are the group ID and category for these items."
  (let ((annotated-items))
    (dolist (item response-items annotated-items)
      (let ((cand (consult--tofu-append item pos)))
        ;; Preserve existing `multi-category' datum of the candidate.
        (if (get-text-property 0 'multi-category cand)
            (when face (add-text-properties 0 (length item) face cand))
          ;; Attach `multi-category' datum and face.
          (add-text-properties 0 (length item)
                               `(multi-category (,category . ,item) ,@face) cand))
        (push cand annotated-items)))))

(defun cw--annotate (sources cand)
  (let ((src (consult--multi-source sources cand)))
    (if-let ((fun (plist-get src :annotate)))
        (funcall fun (cdr (get-text-property 0 'multi-category cand)))
      (plist-get src :name))))

(defun cw--multi (sources &rest options)
  (let* ((sources (consult--multi-enabled-sources sources))
         (selected
          (apply #'consult--read
                 (consult--async-split
                  (consult--async-throttle
                   (cw--multi-async
                    (consult--async-refresh-timer
                     (consult--async-sink))
                    sources)))
                 (append
                  options
                  (list
                   :sort        nil
                   :history     'cw--search-history
                   :initial     (consult--async-split-initial nil)
                   :category    'multi-category
                   :predicate   (apply-partially #'consult--multi-predicate sources)
                   :annotate    (apply-partially #'cw--annotate sources)
                   :group       (apply-partially #'consult--multi-group sources)
                   :lookup      (apply-partially #'consult--multi-lookup sources)
                   :preview-key (consult--multi-preview-key sources)
                   :narrow      (consult--multi-narrow sources)
                   :state       (consult--multi-state sources))))))
    (if (plist-member (cdr selected) :match)
        (when-let (fun (plist-get (cdr selected) :new))
          (funcall fun (car selected))
          (plist-put (cdr selected) :match 'new))
      (when-let (fun (plist-get (cdr selected) :action))
        (funcall fun (car selected)))
      (setq selected `(,(car selected) :match t ,@(cdr selected))))
    selected))


;;; Commands
(defun cw-search ()
  (interactive)
  (let ((consult-async-input-throttle 0.7)
        (consult-async-input-debounce 0.4))
    (cw--multi (list cw-source-elfeed cw-source-gptel
                     cw-source-brave cw-source-wombag
                     cw-source-browser-hist
                     cw-source-invidious)
               :prompt "Search: "

               )))

(defun cw-search-local ()
  (interactive)
  (let ((consult-async-input-throttle 0.7)
        (consult-async-input-debounce 0.4))
    (cw--multi (list cw-source-elfeed
                     cw-source-wombag
                     cw-source-browser-hist)
               :prompt "Search (local sources): "
               )))

;;; Convenience
(defvar cw--search-history nil
  "History variable for `cw-search' and co.")

(defvar cw--count 5
  "Max number of results per source.")

;;; Sources
;;;; gptel
(defvar cw-source-gptel
  `(:name     "gptel"
              :narrow   ?g
              :category 'consult-web
              :face     font-lock-operator-face
              :annotate ,#'cw-gptel-annotate
              :state    ,#'cw--gptel-state
              :items    ,#'cw--gptel-request
              :preview-key ,consult-web-preview-key
              :enabled  ,(lambda () (fboundp 'gptel))))

(defun cw--gptel-state ()
  "gptel result preview function."
  (let ((query-sent) (buffer-preview (consult--buffer-preview)))
    (lambda (action cand)
      (pcase action
        ('exit (funcall buffer-preview 'exit cand))
        ((or 'preview 'return)
         (if cand
             (let* ((props (text-properties-at 0 cand))
                    (query (plist-get props :query))
                    (gptel-buffer (gptel "*cw-gptel*")))
               (with-current-buffer gptel-buffer
                 (unless query-sent
                   (erase-buffer)
                   (insert (gptel-prompt-prefix-string) query)
                   (setq query-sent t)
                   (gptel-send)))
               (funcall buffer-preview 'preview gptel-buffer))
           (funcall buffer-preview 'preview cand)))))))

(defun cw--gptel-request (query callback)
  ""
  (let ((gptel-max-tokens 24)
        (gptel-use-curl))
    (gptel-request query
      :system "Respond in 10 words or less."
      :callback
      (lambda (response _)
        (when response
          (setq response
                (propertize (string-trim-right response)
                            :title response
                            :source "gptel"
                            :query query
                            :model gptel-model
                            :stream gptel-stream
                            :backend (gptel-backend-name gptel-backend)))
          (funcall callback (list response)))))))


(cl-defun cw--gptel-request (query callback)
  ""
 (pcase-let* ((`(,input . ,opts) (consult--command-split query))
               (remaining-opts (list))
               (args (list))
               )
    (if (and query input) (setq cw-gptel-query input))
    (cl-loop for opt in opts
             do
             (pcase-let* ((`(,key . ,val) (consult-web--extract-opt-pair opt opts (list "--group" ":group"))))

               (when key
                 (setq args (append args (list key val)))
                 (setq remaining-opts (cl-delete-duplicates (append remaining-opts (list opt (format "%s" val))))))
               )))

  (let* ((model (or (plist-get args :model) nil))
         (backend (or (plist-get args :backend) nil))
         (backend (and backend (car (seq-filter (lambda (item) (when (string-match (format "%s" backend) item) item)) (mapcar #'car gptel--known-backends)))))
         (backend (or backend (gptel-backend-name gptel-backend)))
         (backend-struct  (cdr (assoc (format "%s" backend) gptel--known-backends)))
         (model (if model (format "%s" model)))
         (model (or (and model backend-struct (member model (cl-struct-slot-value (type-of backend-struct) 'models backend-struct)) model)
                    (and model gptel-backend (member model (cl-struct-slot-value (type-of gptel-backend) 'models gptel-backend)) model)
                    (and backend-struct (car (cl-struct-slot-value (type-of backend-struct) 'models backend-struct)))
                    (and gptel-backend (car (cl-struct-slot-value (type-of gptel-backend) 'models gptel-backend)))))
         (gptel-model (or model gptel-model))
         (gptel-backend (or backend-struct gptel-backend))
         (gptel-max-tokens 24)
         (gptel-use-curl))
    (gptel-request cw-gptel-query
        :system "Respond in 10 words or less."
        :callback
        (lambda (response _)
          (when response
            (setq response
                  (propertize (string-trim-right response)
                              :title response
                              :source "gptel"
                              :query cw-gptel-query
                              :model gptel-model
                              :stream gptel-stream
                              :backend (gptel-backend-name gptel-backend))))
          (funcall callback (list response))))))

(defun cw-gptel-annotate (cand)
  ""
  (let* ((props (text-properties-at 0 cand))
         (model (plist-get props :model))
         (stream (plist-get props :stream))
         (backend (plist-get props :backend)))
    (concat " " (propertize " " 'display '(space :align-to center))
            (propertize backend 'face 'font-lock-variable-name-face)
            (propertize (format ":%s" model) 'face 'font-lock-warning-face)
            (and stream (propertize " ~stream~ " 'face 'font-lock-comment-face)))))

;;;; brave
(defvar cw-source-brave
  `(:name     "Brave"
              :narrow   ?b
              :category consult-web
              :state    ,#'cw--brave-state
              :items    ,#'cw--brave-request
              :preview-key ,consult-web-preview-key
              :enabled  ,(lambda () cw-brave-api-key)))

(defun cw--eww-readable-once ()
  (eww-readable)
  (remove-hook 'eww-after-render-hook #'cw--eww-readable-once))

(defun cw--brave-state ()
  (let ((buffer-preview (consult--buffer-preview)))
    (lambda (action cand)
      (pcase action
        ('exit (funcall buffer-preview 'exit cand))
        ((or 'preview 'return)
         (if cand
             (when-let* ((props (text-properties-at 0 cand))
                         (url (or (plist-get props :url)
                                  (plist-get props :search-url))))
               (if (eq action 'preview)
                   (progn
                     (add-hook 'eww-after-render-hook #'cw--eww-readable-once)
                     (funcall buffer-preview 'preview (eww-browse-url url)))
                 (browse-url url)))
           (funcall buffer-preview 'preview cand)))))))

(defun cw--brave-request (query callback)
  (apply
   #'plz 'get (cw-brave-url-string query)
   (cw-brave-query-args
       (lambda (attrs)
         (when-let* ((raw-results (map-nested-elt attrs '(:web :results)))
                     (annotated-results
                      (mapcar
                       (lambda (item)
                         (let* ((title (map-elt item :title))
                                (search-url (cw-brave-url-string query))
                                (url (map-elt item :url))
                                (urlobj (and url (url-generic-parse-url url)))
                                (domain (and (url-p urlobj) (url-domain urlobj)))
                                (domain (and (stringp domain)
                                             (propertize domain 'face 'font-lock-variable-name-face)))
                                (path (and (url-p urlobj) (url-filename urlobj)))
                                (path (and (stringp path)
                                           (propertize path 'face 'font-lock-warning-face)))
                                (decorated (concat title "\t"
                                                   (propertize " " 'display '(space :align-to center))
                                                   domain path
                                                   )))
                           (propertize decorated
                                       :title title
                                       :url url
                                       :search-url search-url
                                       :query query)))
                       raw-results)))
           (funcall callback annotated-results))))))

(defvar cw-brave-url "https://api.search.brave.com/res/v1/web/search")
(defvar cw-brave-api-key nil)
(setq cw-brave-api-key #'my:brave-key)

(defun cw-brave-url-string (query)
  (concat cw-brave-url "?"
          (url-build-query-string
           `(("q" ,(url-hexify-string query))
             ("count" ,(format "%s" cw--count))
             ("page" ,(format "%s" 0))))))

(defun cw-brave-query-args (plz-callback)
  (declare (indent 1))
  (list :headers `(("User-Agent" . "Emacs:consult-web/0.1 (Emacs consult-web package; https://github.com/armindarvish/consult-web)")
                   ("Accept" . "application/json")
                   ("Accept-Encoding" . "gzip")
                   ("X-Subscription-Token" . ,(let ((key cw-brave-api-key))
                                                (if (functionp key) (funcall key) key))))
        :as (lambda () (json-parse-buffer :object-type 'plist))
        :then plz-callback
        :else (lambda (plz-error) (message "%S" plz-error))))

;;;; Elfeed
(defvar cw-source-elfeed
  `(:name     "Elfeed"
              :narrow   ?e
              :category consult-web
              :items    ,#'cw--elfeed-search
              :preview-key ,consult-web-preview-key
              :state    ,#'cw--elfeed-state
              :enabled  ,(lambda () (boundp 'elfeed-db))))

(defun cw--elfeed-state ()
  (let ((buffer-preview (consult--buffer-preview)))
    (lambda (action cand)
      (pcase action
        ('exit (funcall buffer-preview 'exit cand))
        ((or 'preview 'return)
         (if cand
             (when-let* ((entry (get-text-property 0 :entry cand))
                         (buf (elfeed-show-entry entry)))
               (funcall buffer-preview 'preview buf))
           (funcall buffer-preview 'preview nil)))))))

(defun cw--elfeed-search (query)
  (let* ((elfeed-search-filter (concat (format "#%d " cw--count) query))
         (filter (elfeed-search-parse-filter elfeed-search-filter))
         (head (list nil)) (tail head) (count 0)
         (lexical-binding t)
         (search-func (byte-compile (elfeed-search-compile-filter filter))))
    (with-elfeed-db-visit (entry feed)
      (when (funcall search-func entry feed count)
        (setf (cdr tail) (list entry)
              tail (cdr tail)
              count (1+ count))))
    (when-let ((entries (cdr head)))
      (cw-elfeed-annotate entries))))

(defun cw-elfeed-annotate (entries)
  (let ((annotated-entries))
    (dolist (entry entries annotated-entries)
      (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
             (title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
             (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
             (feed (elfeed-entry-feed entry))
             (feed-title
              (when feed
                (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
             (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
             (tags-str (mapconcat
                        (lambda (s) (propertize s 'face 'elfeed-search-tag-face))
                        tags ","))
             (title-width ;; (- (window-width) 20 elfeed-search-trailing-width)
              60
              )
             (title-column (elfeed-format-column
                            title (elfeed-clamp
                                   elfeed-search-title-min-width
                                   title-width
                                   elfeed-search-title-max-width)
                            :left)))
        (push (propertize
               (concat (propertize date 'face 'elfeed-search-date-face) " "
                       (propertize title-column 'face title-faces 'kbd-help title)
                       (when feed-title
                         (concat (propertize feed-title 'face 'elfeed-search-feed-face) " "))
                       (when tags (concat "(" tags-str ")")))
               :entry entry
               :url (elfeed-entry-link entry))
              annotated-entries)))))

;;;; Wombag
(defvar cw-source-wombag
  `(:name     "Wallabag"
              :narrow   ?w
              :category consult-web
              :items    ,#'cw--wombag-search
              :state    ,#'cw--wombag-state
              :enabled  ,(lambda () (featurep 'wombag-search))))

(defun cw--wombag-search (query)
  (let* ((wombag-search-filter (concat (format "#%d " cw--count) query))
         (filter (wombag-search-parse-filter
                  wombag-search-filter wombag-search-columns))
         (entries (wombag-db-get-entries filter wombag-search-columns)))
    (when entries
      (let ((wombag-search-title-width 60))
        (mapcar (lambda (entry) (propertize (wombag-search-format-entry entry)
                                            :entry entry
                                            :url (alist-get 'url entry)))
                entries)))))

(defun cw--wombag-state ()
  (let ((buffer-preview (consult--buffer-preview)))
    (lambda (action cand)
      (pcase action
        ('exit (funcall buffer-preview 'exit cand))
        ((or 'preview 'return)
         (if cand
             (when-let* ((entry (get-text-property 0 :entry cand))
                         (buf (wombag-show-entry entry)))
               (funcall buffer-preview 'preview buf))
           (funcall buffer-preview 'preview nil)))))))

;;;; Browser hist
(defvar cw-source-browser-hist
  `(:name     "Browser history"
              :narrow   ?h
              :category consult-web
              :items    ,#'cw--browser-hist-search
              :state    ,#'cw--brave-state
              :enabled  ,(lambda () (fboundp 'browser-hist-search))))

(defun cw--browser-hist-search (query)
  (when (require 'browser-hist nil t)
    (when-let ((results (browser-hist--send-query query)))
      (mapcar (pcase-lambda (`(,url . ,title))
                (let* ((urlobj (and url (url-generic-parse-url url)))
                       (domain (and (url-p urlobj) (url-domain urlobj)))
                       (domain (and (stringp domain)
                                    (propertize domain 'face 'font-lock-variable-name-face)))
                       (path (and (url-p urlobj) (url-filename urlobj)))
                       (path (and (stringp path)
                                  (propertize path 'face 'font-lock-warning-face)))
                       (decorated (concat
                                   (truncate-string-to-width (or title url) (floor (window-width) 2))
                                   "\t"
                                   (propertize " " 'display '(space :align-to center))
                                   domain path)))
                  (propertize decorated
                              :title title
                              :url url
                              :query query)))
              results))))


;;;; Invidious
(defvar cw-source-invidious
  `(:name     "Youtube"
              :narrow   ?y
              :category consult-web
              :items    ,#'cw--invidious-search
              :state    ,#'cw--brave-state
              :hidden   t))


(defface cw--invidious-published-face
  '((((class color) (background light)) (:foreground "#a0a"))
    (((class color) (background dark))  (:foreground "#7a7")))
  "Face used for the video published date.")

(defface cw--invidious-author-face
  '((((class color) (background light)) (:foreground "#aa0"))
    (((class color) (background dark))  (:foreground "#ff0")))
  "Face used for channel names.")

(defface cw--invidious-length-face
  '((((class color) (background light)) (:foreground "#aaa"))
    (((class color) (background dark))  (:foreground "#77a")))
  "Face used for the video length.")

(defvar cw--invidious-servers nil)

(defun cw--invidious-state ()
  (let ((buffer-preview (consult--buffer-preview)))
    (lambda (action cand)
      (pcase action
        ('exit (funcall buffer-preview 'exit cand))
        ((or 'preview 'return)
         (if cand
             (when-let* ((props (text-properties-at 0 cand))
                         (url (or (plist-get props :url)
                                  (plist-get props :search-url))))
               (if (eq action 'preview)
                   (progn
                     (add-hook 'eww-after-render-hook #'cw--eww-readable-once)
                     (funcall buffer-preview 'preview (eww-browse-url url)))
                 (browse-url url)))
           (funcall buffer-preview 'preview cand)))))))

(defun cw--get-invidious-servers (&optional rotate)
  (when (and cw--invidious-servers rotate)
    (setq cw--invidious-servers
          (nconc (cdr cw--invidious-servers)
                 (list (car cw--invidious-servers)))))
  (or cw--invidious-servers
      (setq cw--invidious-servers
            (when-let ((raw
                        (plz 'get (concat "https://api.invidious.io/instances.json"
                                          "?pretty=1&sort_by=type,users")
                          :then 'sync)))
              (thread-last
                (json-parse-string raw :object-type 'plist :array-type 'list)
                (cl-remove-if-not (lambda (s) (eq t (plist-get (cadr s) :api))))
                (mapcar #'car))))))

(defun cw--invidious-search (terms callback)
  (let* ((params (url-build-query-string
                  `(("q" ,terms)
                    ("page" "1")
                    ;; Fields are ignored right now, this is for the future
                    ("fields" "title,videoId,author,authorId,authorUrl,lengthSeconds,published")
                    ;; ("type" "video" "playlist")
                    ("sort_by" "relevance"))))
         (api-url (car (cw--get-invidious-servers)))
         (query-url (concat api-url "/api/v1/search?" params)))
    (plz 'get query-url
      :as (lambda () (json-parse-buffer :object-type 'plist))
      :then
      (lambda (response)
        "Return list of candidates to cw."
        (when response
          (thread-last response
                       ;; (seq-take response cw--count)
                       (mapcar
                        (lambda (result)
                          (pcase (plist-get result :type)
                            ("channel"
                             (propertize
                              (concat (propertize "[CHANNEL] "
                                                  'face 'cw--invidious-published-face)
                                      " " (truncate-string-to-width (plist-get result :description) 60) " "
                                      (propertize " " 'display `(space :align-to ,(floor (* (window-width) 3) 5)))
                                      (propertize (if-let ((subs (plist-get result :subCount)))
                                                      (format "%4s subs" (file-size-human-readable subs 'si))
                                                    (make-string 11 ? ))
                                                  'face 'cw--invidious-length-face)
                                      " " (truncate-string-to-width
                                           (propertize (plist-get result :author)
                                                       'face 'cw--invidious-author-face)
                                           40 nil ? ))
                              :url (format "https://www.youtube.com/%s/videos" (plist-get result :channelHandle))
                              :author-url (format "https://www.youtube.com%s" (plist-get result :authorUrl))))
                            ("playlist"
                             (propertize
                              (concat (propertize "[PLAYLIST]"
                                                  'face 'cw--invidious-published-face)
                                      " " (plist-get result :title) " "
                                      (propertize " " 'display `(space :align-to ,(floor (* (window-width) 3) 5)))
                                      (propertize (format "%4d Videos " (plist-get result :videoCount))
                                                  'face 'cw--invidious-length-face)
                                      " " (truncate-string-to-width
                                           (propertize (plist-get result :author)
                                                       'face 'cw--invidious-author-face)
                                           40 nil ? ))
                              :url (format "https://www.youtube.com/watch?list=%s"
                                           (plist-get result :playlistId))
                              :author-url (format "https://www.youtube.com%s"
                                                  (plist-get result :authorUrl))))
                            ("video"
                             (propertize
                              (concat (propertize
                                       (format-time-string
                                        "%Y-%m-%d"
                                        (if-let ((published (plist-get result :published)))
                                            (seconds-to-time published) 0))
                                       'face 'cw--invidious-published-face)
                                      " " (plist-get result :title) " "
                                      (propertize " " 'display `(space :align-to ,(- (floor (* (window-width) 3) 5)
                                                                                     12)))
                                      (and-let* ((duration (plist-get result :lengthSeconds))
                                                 (hours (floor duration 3600))
                                                 (minutes (floor (mod duration 3600) 60))
                                                 (seconds (mod duration 60)))
                                        (propertize
                                         (format "(%02d:%02d:%02d) " hours minutes seconds)
                                         'face 'cw--invidious-length-face))
                                      (propertize
                                       (if-let ((views (plist-get result :viewCount)))
                                           (format "%4s views" (file-size-human-readable views 'si))
                                         (make-string 11 ? ))
                                       'face 'cw--invidious-length-face)
                                      " " (truncate-string-to-width
                                           (propertize (plist-get result :author)
                                                       'face 'cw--invidious-author-face)
                                           40 nil ? ))
                              :url (format "https://www.youtube.com/watch?v=%s"
                                           (plist-get result :videoId))
                              :author-url (format "https://www.youtube.com%s"
                                                  (plist-get result :authorUrl)))))))
                       (seq-filter (lambda (result) (not (null result))))
                       (funcall callback)))))))

;;; Feature

(provide 'cw)
;;; cw.el ends here


;; Local Variables:
;; eval: (outline-minor-mode 1)
;; End

#+end_src

#+RESULTS:
: cw

* test
#+begin_src emacs-lisp :results verbatim drawer
(cw--brave-request "emacs" #'browse-url)
#+end_src

#+begin_src emacs-lisp
cw-source-gptel
#+end_src

#+begin_src emacs-lisp
(defun cw-search ()
  (interactive)
  (let ((consult-async-input-throttle 0.7)
        (consult-async-input-debounce 0.4))
    (cw--multi (list cw-source-gptel
                     cw-source-brave)
               :prompt "Search: "
               )))
#+end_src

#+RESULTS:
: cw-search-test

#+begin_src emacs-lisp
(setq consult-web-dynamic-sources '("elfeed" "Brave"))
#+end_src

#+RESULTS:
| elfeed | Brave |

#+begin_src emacs-lisp
(defun consult-web-multi-test ()
  (interactive)
  (let ((consult-async-input-throttle consult-web-dynamic-input-throttle)
        (consult-async-input-debounce consult-web-dynamic-input-debounce))
    (cw--multi (list consult-web--source-gptel)
                     (cdr consult-web--source-brave))
               :prompt "Search: "
               :preview-key "C-o"
               ))
#+end_src
* Karthink's Demo
#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
(require 'consult-web)
(require 'consult-web-brave)
(require 'consult-web-gptel)
(require 'plz)

(defun cw--multi-search (async)
  (let ((all-items))
    (lambda (action)
      (pcase action
        ((pred stringp)
         (when (> (length action) 2)

           ;; QUERY GPTEL
           (let ((gptel-max-tokens 24))
             (gptel-request action
               :system "Respond in 10 words or less."
               :callback
               (lambda (response _)
                 (if response
                     (let ((gptel-result
                            (cw-gptel-format-candidate
                             (list :title response
                                   :source "gptel"
                                   :query action
                                   :model gptel-model
                                   :stream gptel-stream
                                   :backend (gptel-backend-name gptel-backend)))))
                       (setf (alist-get 'gptel all-items) (list gptel-result))
                       (funcall async 'flush)
                       ;; NOTE: don't use mapcan/nconc here, they are destructive
                       (funcall async (apply #'append
                                             (mapcar #'cdr all-items))))
                   (setf (alist-get 'gptel all-items) nil)))))

           ;; QUERY BRAVE
           (apply #'plz 'get
                  (consult-web--brave-url-string action)
                  (consult-web-brave-query-args
                      (lambda (ht)
                        (let* ((raw-results (map-nested-elt ht '("web" "results")))
                               (brave-results (mapcar (lambda (item)
                                                        (cw-brave-format-candidate
                                                         `(:source "Brave"
                                                           :query action
                                                           :search-url ,(consult-web--brave-url-string action)
                                                           :url ,(format "%s" (map-elt item "url"))
                                                           :title ,(format "%s" (map-elt item "title")))))
                                                      raw-results)))
                          (setf (alist-get 'brave-search all-items) brave-results)
                          (funcall async 'flush)
                          (funcall async (apply #'append
                                                (mapcar #'cdr all-items)))))))

           ;; QUERY ELFEED
           (if-let* ((raw-results (consult-web--elfeed-fetch-results action))
                       (elfeed-results (mapcar #'consult-web-dynamic--elfeed-format-candidate
                                               raw-results)))
               (progn
                 (setf (alist-get 'elfeed all-items) elfeed-results)
                 (funcall async 'flush)
                 (funcall async (apply #'append (mapcar #'cdr all-items))))
             (setf (alist-get 'elfeed all-items) nil))))
        (_ (funcall async action))))))


;;; Metadata handling (all sources)

(defun cw-group-function (cand transform)
  (if transform
      cand
    (get-text-property 0 :source cand)))

(defvar cw-actions
  `(("gptel"
     :on-callback ,#'consult-web--gptelbuffer-preview
     :on-preview  ,#'consult-web--gptelbuffer-preview
     :on-return   ,#'identity)
    ("Brave"
     :on-callback ,#'consult-web--default-callback
     :on-preview ,#'consult-web--default-url-preview
     :on-return   ,#'identity)
    ("elfeed"
     :on-callback ,#'consult-web--elfeed-preview
     :on-preview  ,#'consult-web--elfeed-preview
     :on-return   ,#'identity)))

(defun cw--dynamic-state-function ()
  (lambda (action cand &rest args)
    (if cand
        (let* ((source (get-text-property 0 :source cand))
               (state (map-nested-elt cw-actions `(,source :state)))
               (preview (map-nested-elt cw-actions `(,source :on-preview)))
               (return (map-nested-elt cw-actions `(,source :on-return))))
          (if state
              (funcall state action cand args)
            (pcase action
              ('preview
               (if preview (funcall preview cand) (consult-web--default-url-preview cand)))
              ('return
               (if return (funcall return cand) cand))))))))

;;; gptel-specific

(defun cw-gptel-format-candidate (attrs)
  (let* ((title (propertize
                 (consult-web--set-string-width
                  (plist-get attrs :title) (floor (* (frame-width) 0.4)))
                 'face 'consult-web-ai-source-face))
         (query (plist-get attrs :query))
         (source (plist-get attrs :source))
         (model (plist-get attrs :model))
         (backend (plist-get attrs :backend))
         (stream (plist-get attrs :stream))
         (match-str (and (stringp query)
                         (consult--split-escaped
                          (car (consult--command-split query)))))
         (str (concat title
                      (when backend (concat
                                     (propertize (format "\t%s" backend) 'face 'consult-web-domain-face)
                                     (if model (propertize (format ":%s" model) 'face 'consult-web-path-face))))
                      (when stream (propertize " ~stream~ " 'face 'consult-web-source-face))
                      (when source (concat "\t" source))))
         (str (apply #'propertize str attrs)))
    str))

;;; Brave-specific

(defun consult-web--brave-url-string (query)
  (concat consult-web-brave-url "?"
          (url-build-query-string
           `(("q" ,(url-hexify-string query))
             ("count" ,(format "%s" 5))
             ("page" ,(format "%s" 0))))))

(defun consult-web-brave-query-args (callback)
  (declare (indent 1))
  (list :headers `(("User-Agent" . "Emacs:consult-web/0.1 (Emacs consult-web package; https://github.com/armindarvish/consult-web)")
                   ("Accept" . "application/json")
                   ("Accept-Encoding" . "gzip")
                   ("X-Subscription-Token" . ,(consult-web-expand-variable-function consult-web-brave-api-key)))
        :as #'json-parse-buffer
        :then callback
        :else (lambda (plz-error) (print plz-error (get-buffer "*scratch*")))))

(defun cw-brave-format-candidate (attrs)
  (let* ((title (propertize
                 (consult-web--set-string-width
                  (plist-get attrs :title) (floor (* (frame-width) 0.4)))
                 'face 'consult-web-default-face))
         (url (plist-get attrs :url))
         (urlobj (and url (url-generic-parse-url url)))
         (domain (and (url-p urlobj) (url-domain urlobj)))
         (domain (and (stringp domain) (propertize domain 'face 'consult-web-domain-face)))
         (path (and (url-p urlobj) (url-filename urlobj)))
         (path (and (stringp path) (propertize path 'face 'consult-web-path-face)))
         (source (plist-get attrs :source))
         (source (and (stringp source) (propertize source 'face 'consult-web-source-face)))
         (query (plist-get attrs :query))
         (match-str (and (stringp query)
                         (consult--split-escaped
                          (car (consult--command-split query)))))
         (str (apply #'propertize title attrs)))
    str))


;;; Commands

;;;###autoload
(defun cw-search-demo ()
  (interactive)
  (let* ((consult-async-refresh-delay consult-web-dynamic-refresh-delay)
         (consult-async-input-throttle consult-web-dynamic-input-throttle)
         (consult-async-input-debounce consult-web-dynamic-input-debounce)
         (selected
          (consult--read
           (consult--async-split
            (consult--async-throttle
             (cw--multi-search
              (consult--async-refresh-timer
               (consult--async-sink)))))
           :initial "#"
           :prompt "Search: "
           :state (cw--dynamic-state-function)
           :category 'consult-web
           :preview-key consult-web-preview-key
           :lookup (consult-web--lookup-function)
           :annotate #'consult-web--annotate-function
           :group #'cw-group-function)))
    (when selected
      (thread-first
        (get-text-property 0 :source selected)
        (alist-get cw-actions nil nil #'equal)
        (plist-get :on-callback)
        (funcall selected)))))

(provide 'cw)
#+end_src
